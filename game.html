<!doctype html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Village ‚Äì 2D Snow Survival (Pixel)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; font-family:Arial,sans-serif; touch-action:none; }

    #game { position:fixed; inset:0; width:100%; height:100%; image-rendering:pixelated; image-rendering:crisp-edges; }
    #fxCanvas { position:fixed; inset:0; width:100%; height:100%; pointer-events:none; z-index:8; }

    #info{
      position:fixed; top:10px; left:10px; z-index:20;
      padding:8px 12px; background:rgba(0,0,0,0.55); color:#fff; font-size:13px;
      border-radius:10px; max-width:min(560px, calc(100vw - 20px));
    }
    #stats{
      position:fixed; top:78px; left:10px; z-index:20;
      padding:6px 10px; background:rgba(0,0,0,0.55); color:#fff; font-size:13px;
      border-radius:10px;
    }
    #heatBar{
      position:fixed; bottom:18px; left:50%; transform:translateX(-50%); z-index:20;
      padding:6px 10px; background:rgba(0,0,0,0.55); color:#fff; font-size:18px;
      border-radius:12px; letter-spacing:2px; user-select:none;
    }

    #minimap{
      position:fixed; right:16px; top:16px; width:180px; height:180px; z-index:22;
      border-radius:16px; overflow:hidden; border:3px solid rgba(255,255,255,0.75);
      background:#0f260f; box-shadow:0 10px 25px rgba(0,0,0,0.35);
    }
    #minimapCanvas{ width:100%; height:100%; image-rendering:pixelated; }

    #mpPanel{
      position:fixed; right:16px; top:212px; width:210px; max-height:260px; overflow-y:auto;
      background:rgba(0,0,0,0.60); color:#fff; padding:8px; font-size:12px;
      border-radius:12px; z-index:22; box-shadow:0 10px 25px rgba(0,0,0,0.35);
    }
    #mpStatus{ font-weight:800; margin-bottom:8px; }
    #mpList .playerRow{ margin-bottom:6px; border-bottom:1px solid rgba(255,255,255,0.15); padding-bottom:6px; }
    #mpList .playerRow:last-child{ border-bottom:none; }
    #mpList button{
      width:100%; margin-top:4px; border:none; padding:5px 7px; border-radius:10px;
      background:#3498db; color:#fff; cursor:pointer; font-size:12px;
    }
    #mpList button:hover{ background:#2980b9; }

    #freezeOverlay{
      position:fixed; inset:0; background:#000; opacity:0; pointer-events:none;
      z-index:50; transition:opacity 1s;
    }
    #freezeText{
      position:fixed; inset:0; display:grid; place-items:center; z-index:51; pointer-events:none;
      opacity:0; transition:opacity 1s; color:#fff; text-align:center; padding:24px; font-weight:800;
    }
    #freezeText .card{
      background:rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.12);
      border-radius:16px; padding:14px 16px; max-width:520px; box-shadow:0 10px 25px rgba(0,0,0,0.35);
    }

    /* Error box (–ø–æ–∫–∞–∑—É—î –ø–æ–º–∏–ª–∫—É JS –∑–∞–º—ñ—Å—Ç—å ‚Äú–ø—Ä–æ—Å—Ç–æ —á–æ—Ä–Ω–æ–≥–æ –µ–∫—Ä–∞–Ω—É‚Äù) */
    #errBox{
      position:fixed; left:10px; right:10px; bottom:10px; z-index:99;
      background:rgba(120,0,0,0.80); color:#fff; padding:10px 12px; border-radius:12px;
      font: 12px/1.35 monospace; display:none; white-space:pre-wrap;
      border:1px solid rgba(255,255,255,0.18);
    }

    /* Touch: —Ç—ñ–ª—å–∫–∏ –õ–Ü–í–ò–ô –¥–∂–æ–π—Å—Ç–∏–∫ + –∫–Ω–æ–ø–∫–∞ —Å–æ–∫–∏—Ä–∏ (–ø—Ä–∞–≤–∏–π –∫—Ä—É–≥ –ø—Ä–∏–±—Ä–∞–Ω–æ) */
    #touchControls{ position:fixed; inset:0; pointer-events:none; z-index:30; display:none; }
    #touchControls .pad{
      position:absolute; width:124px; height:124px; border-radius:50%;
      border:2px solid rgba(255,255,255,0.25);
      background:radial-gradient(circle, rgba(255,255,255,0.12) 0, rgba(0,0,0,0) 60%);
      pointer-events:auto; touch-action:none; backdrop-filter:blur(2px);
    }
    #movePad{ left:18px; bottom:28px; }
    #touchControls .stick{
      position:absolute; width:60px; height:60px; border-radius:50%;
      left:32px; top:32px; background:rgba(46,204,113,0.82); box-shadow:0 0 14px rgba(46,204,113,0.95);
    }
    #actionBtn{
      position:absolute; right:30px; bottom:28px; width:84px; height:84px; border-radius:50%;
      border:none; background:radial-gradient(circle, #ffb347 0, #e67e22 60%);
      box-shadow:0 0 16px rgba(230,126,34,0.95); font-size:34px; color:#fff;
      pointer-events:auto; touch-action:none; user-select:none;
    }
    @media (pointer:coarse){ #touchControls{ display:block; } }
  </style>
</head>
<body>
  <div id="info">
    –ü–ö: WASD ‚Äì —Ä—É—Ö, –º–∏—à–∫–∞ ‚Äì –Ω–∞–ø—Ä—è–º, –õ–ö–ú ‚Äì ü™ì –¥—ñ—è/—Ä—É–±–∫–∞/–∫–Ω–æ–ø–∫–∞<br>
    –¢–µ–ª–µ—Ñ–æ–Ω: –ª—ñ–≤–∏–π –∫—Ä—É–≥ ‚Äì —Ä—É—Ö, ü™ì ‚Äì –¥—ñ—è/—Ä—É–±–∫–∞/–∫–Ω–æ–ø–∫–∞ (–ø—Ä–∞–≤–∏–π –∫—Ä—É–≥ –ø—Ä–∏–±—Ä–∞–Ω–∏–π)
  </div>

  <div id="stats"></div>
  <div id="heatBar"></div>

  <audio id="bgm" src="https://cdn.pixabay.com/audio/2022/03/15/audio_d542afd1d9.mp3" loop></audio>

  <div id="minimap"><canvas id="minimapCanvas" width="180" height="180"></canvas></div>

  <div id="mpPanel">
    <div id="mpStatus">–ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä: –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>
    <div id="mpList"></div>
  </div>

  <canvas id="game"></canvas>
  <canvas id="fxCanvas"></canvas>

  <div id="touchControls">
    <div id="movePad" class="pad"><div id="moveStick" class="stick"></div></div>
    <button id="actionBtn">ü™ì</button>
  </div>

  <div id="freezeOverlay"></div>
  <div id="freezeText">
    <div class="card">
      ‚ùÑÔ∏è –í–∏ –∑–∞–º–µ—Ä–∑–ª–∏‚Ä¶<br><br>
      –ü—ñ–¥—ñ–π–¥—ñ—Ç—å –±–ª–∏–∂—á–µ –¥–æ –≤–æ–≥–Ω–∏—â–∞, –ø–æ–∫–∏ —à–∫–∞–ª–∞ —Ç–µ–ø–ª–∞ –Ω–µ –≤–ø–∞–ª–∞ –¥–æ –Ω—É–ª—è.<br>
      (–©–æ–± –ø–æ—á–∞—Ç–∏ –∑–∞–Ω–æ–≤–æ ‚Äì –æ–Ω–æ–≤–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É)
    </div>
  </div>

  <div id="errBox"></div>

  <!-- Firebase compat (–ø—Ä–∞—Ü—é—î –±–µ–∑ type="module" —ñ –±–µ–∑ import) -->
  <script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore-compat.js"></script>

  <script>
  (function(){
    const errBox = document.getElementById("errBox");
    function showErr(msg){
      errBox.style.display="block";
      errBox.textContent = msg;
    }
    window.addEventListener("error", (e)=> showErr("JS ERROR:\n" + (e.message || e.error || e)));
    window.addEventListener("unhandledrejection", (e)=> showErr("PROMISE ERROR:\n" + (e.reason?.message || e.reason || e)));

    /* =========================
       Firebase (—è–∫ —É —Ç–µ–±–µ)
    ========================= */
    const firebaseConfig = {
      apiKey: "AIzaSyDZEwAbFwLQXxlkkmuMKBFof2J3OE02Egs",
      authDomain: "pine-tycoon.firebaseapp.com",
      projectId: "pine-tycoon",
      storageBucket: "pine-tycoon.firebasestorage.app",
      messagingSenderId: "949986190236",
      appId: "1:949986190236:web:4f5d50078326f5c1981e59",
      measurementId: "G-2DY6KSY4G7"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    /* =========================
       DOM
    ========================= */
    const statsEl = document.getElementById("stats");
    const heatEl  = document.getElementById("heatBar");
    const freezeOverlay = document.getElementById("freezeOverlay");
    const freezeText = document.getElementById("freezeText");

    const mpStatusEl = document.getElementById("mpStatus");
    const mpListEl = document.getElementById("mpList");

    const gameCanvas = document.getElementById("game");
    const gctx = gameCanvas.getContext("2d");

    const fxCanvas = document.getElementById("fxCanvas");
    const fx = fxCanvas.getContext("2d");

    const mini = document.getElementById("minimapCanvas");
    const mctx = mini.getContext("2d");

    /* =========================
       Audio (–±–µ–∑ –∫–Ω–æ–ø–∫–∏ ‚Äú–≥—Ä–∞–π—Ç–µ‚Äù)
    ========================= */
    const music = document.getElementById("bgm");
    music.volume = 0.38;

    let actx = null;
    let audioUnlocked = false;
    function ensureAudio(){
      if (audioUnlocked) return;
      audioUnlocked = true;
      try{
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        actx = new AudioCtx();
        if (actx.state === "suspended") actx.resume().catch(()=>{});
      }catch(e){ actx = null; }
      music.play().catch(()=>{});
    }
    window.addEventListener("pointerdown", ensureAudio, { once:true });
    window.addEventListener("touchstart", ensureAudio, { once:true });

    function playTone({freq=220, dur=0.08, type="sine", vol=0.18, slideTo=null}){
      if (!actx) return;
      const t0 = actx.currentTime;
      const o = actx.createOscillator();
      const g = actx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      if (slideTo != null) o.frequency.exponentialRampToValueAtTime(Math.max(20, slideTo), t0 + dur);
      g.gain.setValueAtTime(vol, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g).connect(actx.destination);
      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }
    function playNoise({dur=0.09, vol=0.12}){
      if (!actx) return;
      const sr = actx.sampleRate;
      const len = Math.floor(sr * dur);
      const buf = actx.createBuffer(1, len, sr);
      const data = buf.getChannelData(0);
      for(let i=0;i<len;i++){
        const t = i/len;
        data[i] = (Math.random()*2-1) * (1 - t) * 0.9;
      }
      const src = actx.createBufferSource();
      src.buffer = buf;
      const g = actx.createGain(); g.gain.value = vol;
      const f = actx.createBiquadFilter(); f.type="highpass"; f.frequency.value=800;
      src.connect(f).connect(g).connect(actx.destination);
      src.start(); src.stop(actx.currentTime + dur + 0.02);
    }
    const SFX = {
      swing(){ ensureAudio(); playTone({freq:260, slideTo:150, dur:0.09, type:"triangle", vol:0.14}); },
      chop(){ ensureAudio(); playNoise({dur:0.08, vol:0.10}); playTone({freq:120, dur:0.06, type:"sine", vol:0.10}); },
      restore(){ ensureAudio(); playTone({freq:320, slideTo:720, dur:0.13, type:"sine", vol:0.12}); playTone({freq:520, slideTo:980, dur:0.12, type:"triangle", vol:0.10}); },
      error(){ ensureAudio(); playTone({freq:180, slideTo:120, dur:0.10, type:"square", vol:0.08}); },
      crack(){ ensureAudio(); playNoise({dur:0.12, vol:0.08}); playTone({freq:90, dur:0.10, type:"sine", vol:0.08}); }
    };

    /* =========================
       Helpers
    ========================= */
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };
    const rand = (a,b)=> a + Math.random()*(b-a);
    function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }
    function easeOutQuint(t){ return 1 - Math.pow(1-t, 5); }

    /* =========================
       Pixel –∫–∞–º–µ—Ä–∞ (–≤–Ω—É—Ç—Ä. —Ä–µ–Ω–¥–µ—Ä)
    ========================= */
    const INTERNAL_W = 512;
    const INTERNAL_H = 288;

    const buffer = document.createElement("canvas");
    buffer.width = INTERNAL_W;
    buffer.height = INTERNAL_H;
    const bctx = buffer.getContext("2d");
    bctx.imageSmoothingEnabled = false;
    gctx.imageSmoothingEnabled = false;

    /* –°–≤—ñ—Ç */
    const WORLD_HALF = 160;
    const PPU = 16;

    /* =========================
       –ö–æ–ª—ñ–∑—ñ—ó
    ========================= */
    const colliders = [];
    function addColliderRect(x,y,hw,hh, tag=""){
      const r = { x,y,hw,hh,tag };
      colliders.push(r);
      return r;
    }
    function circleRectCollide(px,py,pr,r){
      const cx = clamp(px, r.x - r.hw, r.x + r.hw);
      const cy = clamp(py, r.y - r.hh, r.y + r.hh);
      const dx = px - cx, dy = py - cy;
      return dx*dx + dy*dy <= pr*pr;
    }
    function isBlocked(px,py,pr){
      return colliders.some(r => circleRectCollide(px,py,pr,r));
    }

    /* =========================
       –°—Ç–∏–ª—å
    ========================= */
    const COL = {
      snow:"#f5f9ff", snow2:"#e9f1ff", shadow:"rgba(0,0,0,0.35)",
      path:"#b38a5d", path2:"#a67c52",
      soil:"#5b3a1a",
      rock:"#7f8894", rock2:"#5f6772",
      mtn:"#6a707a", mtn2:"#52585f",
      btn:"#32d26c", btnGlow:"rgba(50,210,108,0.55)",
      blue:"#2d6cdf", blue2:"#68a0ff",
      green:"#1dbb5a",
      flame:"#ff6b2a", flame2:"#ffcc33"
    };

    const groundPattern = (() => {
      const c = document.createElement("canvas");
      c.width = 64; c.height = 64;
      const x = c.getContext("2d");
      x.fillStyle = COL.snow;
      x.fillRect(0,0,64,64);
      for(let i=0;i<140;i++){
        const px=(Math.random()*64)|0, py=(Math.random()*64)|0;
        x.fillStyle = Math.random()<0.6 ? COL.snow2 : "#ffffff";
        x.fillRect(px,py,1,1);
      }
      return bctx.createPattern(c, "repeat");
    })();

    /* =========================
       –°—É—Ç–Ω–æ—Å—Ç—ñ
    ========================= */
    const houses = [];
    const farms = [];
    const paths = [];
    const rocks = [];
    const mountains = [];
    let trees = [];
    let buttons = [];

    const campfire = { x:0, y:30 };

    function createRestoreButton(x,y,cost,type,target){
      buttons.push({ x,y,cost,type,target, restored:false, phase:Math.random()*Math.PI*2, flash:0 });
    }

    function mkHouseVariant(i){
      const variants = [
        { walls:"#9a6a3d", walls2:"#7c4f2b", roof:"#c84d3a", roof2:"#a73a2a", chimney:true  },
        { walls:"#7d5c3a", walls2:"#5a3f28", roof:"#3d6fb3", roof2:"#2e568f", chimney:false },
        { walls:"#b07d4f", walls2:"#8a5a33", roof:"#3a3a3a", roof2:"#242424", chimney:true  },
        { walls:"#8b8b8b", walls2:"#6f6f6f", roof:"#a63b2f", roof2:"#7f2a22", chimney:false }
      ];
      return variants[i % variants.length];
    }

    function createHouse(x,y, vi=0){
      const v = mkHouseVariant(vi);
      const h = { kind:"small", x,y, w:6, h:6, restored:false, restoreT:0, v, cost:45 };
      houses.push(h);
      createRestoreButton(x, y+4.2, h.cost, "house", h);
    }
    function createBigHouse(x,y, vi=1){
      const v = mkHouseVariant(vi);
      const h = { kind:"big", x,y, w:7, h:7, restored:false, restoreT:0, v, cost:65 };
      houses.push(h);
      createRestoreButton(x, y+4.8, h.cost, "bigHouse", h);
    }
    function createFarm(x,y,w,l, cropType=0){
      const f = { x,y,w,l, restored:false, restoreT:0, cropType, cost:15 };
      farms.push(f);
      createRestoreButton(x, y + l/2 + 1.2, f.cost, "farm", f);
    }
    function createPath(x,y,w,l){
      const p = { x,y,w,l, restored:false, restoreT:0, cost:5 };
      paths.push(p);
      createRestoreButton(x,y,p.cost,"path",p);
    }
    function createRock(x,y,size){
      rocks.push({ x,y,size });
      addColliderRect(x,y, size*0.9, size*0.9, "rock");
    }
    function createMountain(x,y){
      const base = 8 + Math.random()*6;
      const height = 10 + Math.random()*8;
      mountains.push({ x,y,base,height });
      addColliderRect(x,y, base*0.85, base*0.85, "mountain");
    }
    function createMountainsBorder(){
      for(let x=-150;x<=150;x+=15){ createMountain(x,-150); createMountain(x,150); }
      for(let y=-150;y<=150;y+=15){ createMountain(-150,y); createMountain(150,y); }
      for(let i=0;i<35;i++){
        const a=Math.random()*Math.PI*2;
        const r=110 + Math.random()*25;
        createMountain(Math.cos(a)*r, Math.sin(a)*r);
      }
    }

    function createTree(x,y){
      const kind = (Math.random()*3)|0;
      const scale = rand(0.85, 1.25);
      const snowiness = rand(0.55, 1.0);
      const trunk = rand(0.9, 1.35);
      const t = {
        x,y,
        hp: 4 + (Math.random()<0.2 ? 1 : 0),
        falling:false,
        fallT:0,
        fallDir: Math.random()<0.5 ? -1 : 1,
        removed:false,
        collider:null,
        kind, scale, snowiness, trunk
      };
      t.collider = addColliderRect(x,y, 0.85, 0.85, "tree");
      trees.push(t);
    }
    function forestRing(cx,cy, inner, outer, count){
      for(let i=0;i<count;i++){
        const a=Math.random()*Math.PI*2;
        const r=inner + Math.random()*(outer-inner);
        const x=cx + Math.cos(a)*r;
        const y=cy + Math.sin(a)*r;
        if (Math.sqrt(x*x+y*y) < 20) continue;
        createTree(x,y);
      }
    }
    function createForestRocks(count){
      for(let i=0;i<count;i++){
        const a=Math.random()*Math.PI*2;
        const r=30 + Math.random()*70;
        const x=Math.cos(a)*r;
        const y=Math.sin(a)*r;
        if (Math.sqrt(x*x+y*y) < 25){ i--; continue; }
        createRock(x,y, 0.8 + Math.random()*1.4);
      }
    }

    function buildVillage(){
      createHouse(  0,   0, 0);
      createHouse( 18,  -6, 1);
      createHouse(-18,   8, 2);
      createHouse(  0, -20, 3);
      createHouse( 26,  14, 0);
      createHouse(-26, -14, 1);
      createHouse( 36,   0, 2);
      createHouse(-36,   0, 3);
      createHouse( 12,  28, 1);
      createHouse(-12, -30, 0);

      createBigHouse( 30, -28, 2);
      createBigHouse(-30,  28, 3);

      createPath(0,-8,  4,18);
      createPath(0, 8,  4,18);
      createPath(8,0,  18,4);
      createPath(-8,0, 18,4);

      createPath(18,-14, 14,4);
      createPath(-18,14, 14,4);

      createFarm(  0, -36, 12, 7, 0);
      createFarm( 26,   6, 11, 7, 1);
      createFarm(-26,  -6, 11, 7, 2);
    }

    buildVillage();
    forestRing(0,0,24,42,100);
    forestRing(0,0,42,70,140);
    forestRing(0,0,70,100,180);
    createForestRocks(30);
    createMountainsBorder();

    /* =========================
       –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞/—Ç–µ–ø–ª–æ
    ========================= */
    let treesCutTotal = 0;
    let wood = 0;

    const heatMax = 9;
    let heatValue = heatMax;
    let isFrozen = false;

    function updateStats(){ statsEl.textContent = `–î–µ—Ä–µ–≤ –∑—Ä—É–±–∞–Ω–æ: ${treesCutTotal} | –î–µ—Ä–µ–≤–æ: ${wood}`; }
    function updateHeat(){
      const full = Math.round(heatValue);
      let s=""; for(let i=0;i<heatMax;i++) s += i<full ? "üî•" : "¬∑";
      heatEl.textContent = s;
    }
    updateStats(); updateHeat();

    /* =========================
       –ì—Ä–∞–≤–µ—Ü—å/–∫–∞–º–µ—Ä–∞
    ========================= */
    const player = { x:0, y:35, r:0.60, dir:-Math.PI/2, attack:0, attackCooldown:0 };
    const camera = { x:player.x, y:player.y };

    /* –î–µ–Ω—å/–Ω—ñ—á */
    const SWITCH_EVERY = 300;
    const TRANSITION = 14;
    let dayNightTimer = 0;
    let isNight = false;
    let light = 1;
    let fromLight = 1, toLight = 1, transT = 1;

    function updateDayNight(dt){
      dayNightTimer += dt;
      if (dayNightTimer >= SWITCH_EVERY){
        dayNightTimer -= SWITCH_EVERY;
        isNight = !isNight;
        fromLight = light;
        toLight = isNight ? 0 : 1;
        transT = 0;
      }
      if (transT < 1){
        transT = Math.min(1, transT + dt/TRANSITION);
        light = lerp(fromLight, toLight, easeOutQuint(transT));
      }
    }

    /* –ß–∞—Å—Ç–∏–Ω–∫–∏ */
    const particles = [];
    function spawnParticles(type,x,y,count=10){
      for(let i=0;i<count;i++){
        const a=Math.random()*Math.PI*2;
        const sp=rand(1.5,5.5);
        particles.push({ type, x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(0.35,0.75) });
      }
    }

    /* =========================
       –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è: –ü–ö + —Ç–µ–ª–µ—Ñ–æ–Ω
       ‚úÖ –ü—Ä–∞–≤–∏–π –∫—Ä—É–≥ –ü–†–ò–ë–†–ê–ù–û.
       –ù–∞–ø—Ä—è–º –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω—ñ = –Ω–∞–ø—Ä—è–º —Ä—É—Ö—É (–∫–æ–ª–∏ —Ä—É—Ö–∞—î—à—Å—è).
    ========================= */
    const keys = {};
    document.addEventListener("keydown",(e)=>keys[e.code]=true);
    document.addEventListener("keyup",(e)=>keys[e.code]=false);

    let mouseAim = null;
    window.addEventListener("mousemove",(e)=>{ mouseAim={x:e.clientX,y:e.clientY}; });
    window.addEventListener("mouseleave",()=>{ mouseAim=null; });

    const movePad = document.getElementById("movePad");
    const moveStick = document.getElementById("moveStick");
    const actionBtn = document.getElementById("actionBtn");

    let touchMoveX=0, touchMoveY=0;

    function setupMoveStick(pad, stick){
      const stickRadius=30;
      let touchId=null;

      function reset(){
        const rect=pad.getBoundingClientRect();
        const cx=rect.width/2, cy=rect.height/2;
        stick.style.left=(cx-stickRadius)+"px";
        stick.style.top =(cy-stickRadius)+"px";
        touchMoveX=0; touchMoveY=0;
      }
      function updateFromTouch(t){
        const rect=pad.getBoundingClientRect();
        const cx=rect.width/2, cy=rect.height/2;
        let dx=t.clientX - (rect.left+cx);
        let dy=t.clientY - (rect.top +cy);
        const maxR=rect.width/2 - stickRadius;
        const d=Math.hypot(dx,dy);
        if (d>maxR){ dx*=maxR/d; dy*=maxR/d; }
        stick.style.left=(cx-stickRadius+dx)+"px";
        stick.style.top =(cy-stickRadius+dy)+"px";
        touchMoveX=dx/maxR; touchMoveY=dy/maxR;
      }

      pad.addEventListener("touchstart",(e)=>{
        e.preventDefault();
        const t=e.changedTouches[0];
        touchId=t.identifier;
        updateFromTouch(t);
      },{passive:false});

      pad.addEventListener("touchmove",(e)=>{
        e.preventDefault();
        if (touchId===null) return;
        for(const t of e.touches){
          if (t.identifier===touchId){ updateFromTouch(t); break; }
        }
      },{passive:false});

      function end(e){
        if (touchId===null) return;
        for(const t of e.changedTouches){
          if (t.identifier===touchId){ touchId=null; reset(); break; }
        }
      }
      pad.addEventListener("touchend", end, {passive:false});
      pad.addEventListener("touchcancel", end, {passive:false});

      reset();
    }
    if (movePad && moveStick) setupMoveStick(movePad, moveStick);

    /* =========================
       –î—ñ—è (ü™ì) + –∞–Ω—Ç–∏-—Å–ø–∞–º
    ========================= */
    const AXE_COOLDOWN = 0.55;

    function doAction(){
      if (isFrozen) return;
      ensureAudio();
      if (player.attackCooldown > 0) return;

      player.attack = 0.0001;
      player.attackCooldown = AXE_COOLDOWN;

      SFX.swing();
      const used = tryUseNearestButton();
      if (!used) chopNearestTree();
    }

    window.addEventListener("mousedown",(e)=>{ if(e.button===0) doAction(); });
    if (actionBtn){
      const tap=(e)=>{ e.preventDefault(); doAction(); };
      actionBtn.addEventListener("click", tap);
      actionBtn.addEventListener("touchstart", tap, {passive:false});
    }

    function tryUseNearestButton(){
      let best=null, bestD=(2.2*2.2);
      for(const b of buttons){
        if (b.restored) continue;
        const d=dist2(player.x,player.y,b.x,b.y);
        if (d<bestD){ bestD=d; best=b; }
      }
      if (!best) return false;

      if (wood < best.cost){
        best.flash = 0.22;
        SFX.error();
        return true;
      }

      wood -= best.cost;
      best.restored = true;

      if (best.type==="house" || best.type==="bigHouse"){
        best.target.restored = true;
        best.target.restoreT = 0.0001;
        addColliderRect(
          best.target.x, best.target.y,
          best.type==="bigHouse" ? 4.1 : 3.2,
          best.type==="bigHouse" ? 4.1 : 3.2,
          "house"
        );
      } else if (best.type==="farm"){
        best.target.restored = true;
        best.target.restoreT = 0.0001;
        addColliderRect(best.target.x, best.target.y, best.target.w/2, best.target.l/2, "farm");
      } else if (best.type==="path"){
        best.target.restored = true;
        best.target.restoreT = 0.0001;
      }

      spawnParticles("restore", best.x, best.y, 18);
      SFX.restore();
      buttons = buttons.filter(x=>x!==best);

      updateStats();
      return true;
    }

    function chopNearestTree(){
      let best=null, bestD=(2.8*2.8);
      for(const t of trees){
        if (t.falling || t.removed) continue;
        const d=dist2(player.x,player.y,t.x,t.y);
        if (d<bestD){ bestD=d; best=t; }
      }
      if (!best) return;

      best.hp -= 1;
      spawnParticles("chips", best.x, best.y, 12);
      SFX.chop();

      if (best.hp<=0 && !best.falling){
        best.falling=true;
        best.fallT=0;

        const idx=colliders.indexOf(best.collider);
        if (idx!==-1) colliders.splice(idx,1);

        treesCutTotal++;
        wood++;
        updateStats();
        SFX.crack();
      }
    }

    /* =========================
       –†–µ–Ω–¥–µ—Ä helpers
    ========================= */
    function worldToScreen(wx,wy){
      const sx=(wx-camera.x)*PPU + INTERNAL_W/2;
      const sy=(wy-camera.y)*PPU + INTERNAL_H/2;
      return { x:sx, y:sy };
    }
    function drawShadowCircle(ctx,x,y,r){
      ctx.fillStyle = COL.shadow;
      ctx.beginPath();
      ctx.ellipse(x,y,r*1.1,r*0.7,0,0,Math.PI*2);
      ctx.fill();
    }
    function pRect(ctx,x,y,w,h){ ctx.fillRect((x|0),(y|0),(w|0),(h|0)); }

    function drawAxe(ctx,x,y, ang, swing){
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(ang + swing);
      ctx.fillStyle = "#7c4f2b";
      pRect(ctx, -1, -10, 2, 18);
      ctx.fillStyle = "#c3c9d3";
      pRect(ctx, 0, -7, 10, 6);
      ctx.fillStyle = "#9aa2ad";
      pRect(ctx, 0, -7, 10, 2);
      ctx.restore();
    }

    function drawPlayer(ctx, p, time){
      const pos = worldToScreen(p.x,p.y);
      const bob = Math.sin(time*6)*0.8;

      drawShadowCircle(ctx, pos.x, pos.y + 10, 14);

      const r = 10;
      ctx.fillStyle = COL.blue;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y + bob, r, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = COL.blue2;
      ctx.beginPath();
      ctx.arc(pos.x - 3, pos.y - 3 + bob, 4, 0, Math.PI*2);
      ctx.fill();

      const atk = p.attack>0 ? Math.sin(p.attack*Math.PI) : 0;
      const swing = -0.95*atk;

      const axeX = pos.x + Math.cos(p.dir)*14;
      const axeY = pos.y + Math.sin(p.dir)*10 + bob;
      drawAxe(ctx, axeX, axeY, p.dir + Math.PI/2, swing);
    }

    function drawRemotePlayer(ctx, rp, time){
      const pos = worldToScreen(rp.x,rp.y);
      drawShadowCircle(ctx, pos.x, pos.y + 10, 14);

      ctx.fillStyle = rp.color === "green" ? "rgba(29,187,90,0.58)" : "rgba(45,108,223,0.55)";
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 10, 0, Math.PI*2);
      ctx.fill();

      const axeX = pos.x + Math.cos(rp.dir)*14;
      const axeY = pos.y + Math.sin(rp.dir)*10;
      drawAxe(ctx, axeX, axeY, rp.dir + Math.PI/2, 0);

      ctx.font = "bold 12px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillText(rp.name, pos.x+1, pos.y - 14 + 1);
      ctx.fillStyle = "#ffffff";
      ctx.fillText(rp.name, pos.x, pos.y - 14);
    }

    function drawTree(ctx, t){
      const pos = worldToScreen(t.x,t.y);
      const fallDur = 0.72;
      const k = t.falling ? clamp(t.fallT/fallDur, 0, 1) : 0;
      const kk = easeOutQuint(k);
      const ang = t.falling ? (kk * (Math.PI/2) * t.fallDir) : 0;

      const s = t.scale;
      const trunkH = PPU*(0.95*t.trunk)*s;

      drawShadowCircle(ctx, pos.x, pos.y + PPU*0.38, PPU*0.72*s);

      ctx.save();
      ctx.translate(pos.x, pos.y);
      if (t.falling){
        ctx.translate(kk * PPU*0.35 * t.fallDir, kk * PPU*0.08);
      }
      ctx.translate(0, PPU*0.25*s);
      ctx.rotate(ang);
      ctx.translate(0, -PPU*0.25*s);

      ctx.fillStyle = "#6b4625";
      pRect(ctx, -2*s, -trunkH*0.15, 4*s, trunkH);

      const snowA = t.snowiness;
      const topCol = `rgba(233,241,255,${0.65*snowA})`;
      const topCol2 = `rgba(245,249,255,${0.85*snowA})`;

      if (t.kind === 0){
        ctx.fillStyle = topCol2;
        ctx.beginPath();
        ctx.moveTo(0, -PPU*1.65*s);
        ctx.lineTo(PPU*1.0*s, -PPU*0.10*s);
        ctx.lineTo(-PPU*1.0*s, -PPU*0.10*s);
        ctx.closePath(); ctx.fill();

        ctx.fillStyle = topCol;
        ctx.beginPath();
        ctx.moveTo(0, -PPU*1.25*s);
        ctx.lineTo(PPU*0.8*s, -PPU*0.30*s);
        ctx.lineTo(-PPU*0.8*s, -PPU*0.30*s);
        ctx.closePath(); ctx.fill();
      } else if (t.kind === 1){
        ctx.fillStyle = topCol2;
        ctx.beginPath();
        ctx.moveTo(0, -PPU*1.55*s);
        ctx.lineTo(PPU*1.15*s, -PPU*0.25*s);
        ctx.lineTo(0, -PPU*0.05*s);
        ctx.lineTo(-PPU*1.15*s, -PPU*0.25*s);
        ctx.closePath(); ctx.fill();

        ctx.fillStyle = topCol;
        ctx.beginPath();
        ctx.arc(0, -PPU*0.75*s, PPU*0.65*s, 0, Math.PI*2);
        ctx.fill();
      } else {
        ctx.fillStyle = topCol2;
        ctx.beginPath();
        ctx.moveTo(0, -PPU*1.80*s);
        ctx.lineTo(PPU*0.85*s, -PPU*0.05*s);
        ctx.lineTo(-PPU*0.85*s, -PPU*0.05*s);
        ctx.closePath(); ctx.fill();

        ctx.fillStyle = topCol;
        ctx.beginPath();
        ctx.moveTo(0, -PPU*1.10*s);
        ctx.lineTo(PPU*0.65*s, -PPU*0.25*s);
        ctx.lineTo(-PPU*0.65*s, -PPU*0.25*s);
        ctx.closePath(); ctx.fill();
      }

      ctx.restore();
    }

    function drawCampfire(ctx, time){
      const pos = worldToScreen(campfire.x, campfire.y);

      for(let i=0;i<6;i++){
        const a = i*(Math.PI/3);
        const px = pos.x + Math.cos(a)*PPU*1.0;
        const py = pos.y + Math.sin(a)*PPU*0.75;
        ctx.fillStyle = COL.rock2;
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI*2);
        ctx.fill();
      }

      const night = 1 - light;
      const flick = 1 + Math.sin(time*10)*0.12;

      drawShadowCircle(ctx, pos.x, pos.y + 8, 12);

      ctx.fillStyle = COL.flame;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - 18*flick);
      ctx.quadraticCurveTo(pos.x + 10, pos.y - 4, pos.x, pos.y + 10);
      ctx.quadraticCurveTo(pos.x - 10, pos.y - 4, pos.x, pos.y - 18*flick);
      ctx.fill();

      ctx.fillStyle = COL.flame2;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - 12*flick);
      ctx.quadraticCurveTo(pos.x + 7, pos.y - 2, pos.x, pos.y + 7);
      ctx.quadraticCurveTo(pos.x - 7, pos.y - 2, pos.x, pos.y - 12*flick);
      ctx.fill();

      const g = ctx.createRadialGradient(pos.x, pos.y, 12, pos.x, pos.y, 70);
      g.addColorStop(0, `rgba(255,120,60,${0.18 + 0.18*night})`);
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 70, 0, Math.PI*2);
      ctx.fill();
    }

    function drawButton(ctx, b, time){
      const pos = worldToScreen(b.x,b.y);
      const pulse = 1 + Math.sin(time*5 + b.phase)*0.10;

      drawShadowCircle(ctx, pos.x, pos.y + 10, 14);

      ctx.fillStyle = COL.btn;
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y, 14*pulse, 10*pulse, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = COL.btnGlow;
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y, 20*pulse, 14*pulse, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.font = "bold 14px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = (b.flash>0) ? "#ff4d4d" : "#ffffff";
      ctx.fillText(String(b.cost), pos.x, pos.y - 18);
    }

    function drawHouse(ctx, h, time){
      const v = h.v;
      const fade = h.restored ? (0.40 + 0.60*easeOutCubic(h.restoreT)) : 0.38;
      const pos = worldToScreen(h.x,h.y);
      const w = h.w*PPU, l = h.h*PPU;

      drawShadowCircle(ctx, pos.x, pos.y + l*0.18, Math.max(w,l)*0.25);

      ctx.globalAlpha = fade;

      ctx.fillStyle = v.walls;
      pRect(ctx, pos.x - w/2, pos.y - l/2, w, l);

      ctx.fillStyle = "rgba(255,255,255,0.08)";
      pRect(ctx, pos.x - w/2 + 3, pos.y - l/2 + 3, w-6, l-6);

      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.lineWidth = 2;
      ctx.strokeRect((pos.x - w/2)|0, (pos.y - l/2)|0, w|0, l|0);

      const roofH = (h.kind==="big") ? PPU*2.3 : PPU*2.0;
      ctx.fillStyle = v.roof;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - l/2 - roofH);
      ctx.lineTo(pos.x + w/2, pos.y - l/2 + PPU*0.7);
      ctx.lineTo(pos.x, pos.y - l/2 + PPU*2.4);
      ctx.lineTo(pos.x - w/2, pos.y - l/2 + PPU*0.7);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = v.roof2;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - l/2 - roofH);
      ctx.lineTo(pos.x, pos.y - l/2 + PPU*2.4);
      ctx.lineTo(pos.x - w/2, pos.y - l/2 + PPU*0.7);
      ctx.closePath();
      ctx.fill();

      if (v.chimney){
        ctx.fillStyle = "#3b3b3b";
        pRect(ctx, pos.x + w*0.18, pos.y - l/2 - roofH*0.6, PPU*0.55, PPU*1.2);
      }

      ctx.fillStyle = v.walls2;
      pRect(ctx, pos.x - PPU*0.9, pos.y + l*0.10, PPU*1.8, PPU*2.3);

      const night = 1 - light;
      const windowGlow = h.restored ? (0.15 + 0.85*night) : 0.12;

      ctx.fillStyle = `rgba(255,230,160,${0.35*windowGlow})`;
      pRect(ctx, pos.x - PPU*2.1, pos.y - PPU*0.3, PPU*1.2, PPU*1.2);

      ctx.fillStyle = `rgba(255,230,160,${0.45*windowGlow})`;
      pRect(ctx, pos.x + PPU*1.2, pos.y - PPU*0.3, PPU*1.2, PPU*1.2);

      if (h.restored && night > 0.02){
        const g = ctx.createRadialGradient(pos.x, pos.y, 8, pos.x, pos.y, 58);
        g.addColorStop(0, `rgba(255,210,120,${0.18*night})`);
        g.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(pos.x, pos.y, 58, 0, Math.PI*2); ctx.fill();
      }

      ctx.globalAlpha = 1;
    }

    function drawFarm(ctx, f){
      const fade = f.restored ? (0.40 + 0.60*easeOutCubic(f.restoreT)) : 0.38;
      const pos = worldToScreen(f.x,f.y);
      const w = f.w*PPU, l = f.l*PPU;

      drawShadowCircle(ctx, pos.x, pos.y + l*0.22, Math.max(w,l)*0.20);

      ctx.globalAlpha = fade;

      ctx.fillStyle = COL.soil;
      pRect(ctx, pos.x - w/2, pos.y - l/2, w, l);

      ctx.fillStyle = "rgba(0,0,0,0.18)";
      for(let r=0;r<5;r++){
        const yy = pos.y - l/2 + (r+0.5)*(l/5);
        pRect(ctx, pos.x - w/2 + 2, yy, w-4, 1);
      }

      for(let row=0; row<4; row++){
        for(let col=0; col<Math.floor(f.w); col++){
          const cx = pos.x - w/2 + (col+0.5)*PPU;
          const cy = pos.y - l/2 + (row+0.65)*(l/4);

          if (f.cropType === 0){
            ctx.fillStyle = "rgba(255,244,200,0.85)";
            pRect(ctx, cx-1, cy-3, 2, 6);
          } else if (f.cropType === 1){
            ctx.fillStyle = "rgba(120,255,170,0.85)";
            pRect(ctx, cx-1, cy-3, 2, 4);
            ctx.fillStyle = "rgba(255,160,90,0.85)";
            pRect(ctx, cx-1, cy+1, 2, 2);
          } else {
            ctx.fillStyle = "rgba(230,245,255,0.9)";
            pRect(ctx, cx-2, cy-2, 4, 4);
            ctx.fillStyle = "rgba(0,0,0,0.15)";
            pRect(ctx, cx-2, cy+2, 4, 1);
          }
        }
      }

      ctx.globalAlpha = 1;
    }

    function drawPath(ctx, p){
      const fade = p.restored ? (0.45 + 0.55*easeOutCubic(p.restoreT)) : 0.35;
      const pos = worldToScreen(p.x,p.y);
      const w = p.w*PPU, l = p.l*PPU;

      ctx.globalAlpha = fade;
      ctx.fillStyle = COL.path;
      pRect(ctx, pos.x - w/2, pos.y - l/2, w, l);

      ctx.fillStyle = COL.path2;
      for(let i=0;i<14;i++){
        const tx = pos.x - w/2 + Math.random()*w;
        const ty = pos.y - l/2 + Math.random()*l;
        pRect(ctx, tx, ty, 2, 2);
      }
      ctx.globalAlpha = 1;
    }

    function drawRock(ctx, r){
      const pos = worldToScreen(r.x,r.y);
      const s = r.size*PPU;
      drawShadowCircle(ctx, pos.x, pos.y + s*0.22, s*0.55);

      ctx.fillStyle = COL.rock;
      ctx.beginPath();
      ctx.moveTo(pos.x - s*0.6, pos.y);
      ctx.lineTo(pos.x - s*0.2, pos.y - s*0.45);
      ctx.lineTo(pos.x + s*0.55, pos.y - s*0.1);
      ctx.lineTo(pos.x + s*0.35, pos.y + s*0.50);
      ctx.lineTo(pos.x - s*0.35, pos.y + s*0.45);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = COL.rock2;
      ctx.beginPath();
      ctx.moveTo(pos.x - s*0.2, pos.y - s*0.45);
      ctx.lineTo(pos.x + s*0.15, pos.y - s*0.30);
      ctx.lineTo(pos.x + s*0.55, pos.y - s*0.1);
      ctx.lineTo(pos.x + s*0.05, pos.y - s*0.05);
      ctx.closePath();
      ctx.fill();
    }

    function drawMountain(ctx, m){
      const pos = worldToScreen(m.x,m.y);
      const base = m.base*PPU;
      const h = m.height*PPU;

      drawShadowCircle(ctx, pos.x, pos.y + base*0.25, base*0.80);

      ctx.fillStyle = COL.mtn;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - h*0.55);
      ctx.lineTo(pos.x + base*0.65, pos.y + base*0.50);
      ctx.lineTo(pos.x - base*0.65, pos.y + base*0.50);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = COL.mtn2;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - h*0.55);
      ctx.lineTo(pos.x, pos.y + base*0.50);
      ctx.lineTo(pos.x - base*0.65, pos.y + base*0.50);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = COL.snow2;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - h*0.55);
      ctx.lineTo(pos.x + base*0.18, pos.y - h*0.30);
      ctx.lineTo(pos.x, pos.y - h*0.18);
      ctx.lineTo(pos.x - base*0.20, pos.y - h*0.30);
      ctx.closePath();
      ctx.fill();
    }

    /* =========================
       –ú—ñ–Ω—ñ–º–ø–∞
    ========================= */
    const remoteStates = new Map();
    function updateMinimap(){
      mctx.clearRect(0,0,180,180);
      mctx.fillStyle="#132e13";
      mctx.fillRect(0,0,180,180);

      const scale = 180/(WORLD_HALF*2);
      const toM=(wx,wy)=>({ x:(wx+WORLD_HALF)*scale, y:(wy+WORLD_HALF)*scale });

      mctx.fillStyle="rgba(60,255,60,0.65)";
      for(const c of colliders){
        const p=toM(c.x,c.y);
        mctx.fillRect(p.x|0, p.y|0, 2, 2);
      }

      remoteStates.forEach((d)=>{
        const p=toM(d.x,d.y);
        mctx.fillStyle="rgba(90,160,255,0.75)";
        mctx.fillRect((p.x|0)-1,(p.y|0)-1,3,3);
      });

      const mp=toM(player.x,player.y);
      mctx.save();
      mctx.translate(mp.x, mp.y);
      mctx.rotate(player.dir);
      mctx.fillStyle="#ffffff";
      mctx.beginPath();
      mctx.moveTo(0,-6); mctx.lineTo(4,4); mctx.lineTo(-4,4);
      mctx.closePath(); mctx.fill();
      mctx.restore();
    }

    /* =========================
       –°–Ω—ñ–≥ FX
    ========================= */
    let snowflakes=[];
    function resize(){
      const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
      gameCanvas.width = Math.floor(innerWidth*dpr);
      gameCanvas.height= Math.floor(innerHeight*dpr);
      gctx.setTransform(dpr,0,0,dpr,0,0);

      fxCanvas.width = Math.floor(innerWidth*dpr);
      fxCanvas.height= Math.floor(innerHeight*dpr);
      fx.setTransform(dpr,0,0,dpr,0,0);
    }
    function initSnow(count=150){
      snowflakes=[];
      for(let i=0;i<count;i++){
        snowflakes.push({
          x:Math.random()*innerWidth,
          y:Math.random()*innerHeight,
          r:1 + Math.random()*1.8,
          speed:22 + Math.random()*36,
          drift:-10 + Math.random()*20
        });
      }
    }
    function updateSnow(dt){
      fx.clearRect(0,0,innerWidth,innerHeight);
      const night = 1 - light;
      fx.fillStyle = `rgba(255,255,255,${0.90 - 0.18*night})`;
      for(const f of snowflakes){
        f.y += f.speed*dt;
        f.x += f.drift*dt;
        if (f.y > innerHeight + f.r){ f.y=-f.r; f.x=Math.random()*innerWidth; }
        if (f.x < -10) f.x=innerWidth+10;
        if (f.x > innerWidth+10) f.x=-10;
        fx.beginPath(); fx.arc(f.x,f.y,f.r,0,Math.PI*2); fx.fill();
      }
    }

    /* =========================
       –ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä (compat)
    ========================= */
    let currentUserUid=null;
    let currentUserName=null;

    const remotePlayers = new Map();
    const MAX_INACTIVE_MS = 30000;
    let lastSyncTime = 0;
    const SYNC_INTERVAL = 200;

    function hashUid(uid){
      let h=0;
      for(let i=0;i<uid.length;i++) h = (h*31 + uid.charCodeAt(i))|0;
      return Math.abs(h);
    }

    function joinToPlayer(uid){
      const data = remoteStates.get(uid);
      if (!data) return;
      player.x = data.x + 2;
      player.y = data.y + 2;
      player.dir = data.dir ?? player.dir;
    }

    function updateMpUI(){
      if (!currentUserUid) mpStatusEl.textContent = "–ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä: —É–≤—ñ–π–¥—ñ—Ç—å —É –∞–∫–∞—É–Ω—Ç –Ω–∞ –≥–æ–ª–æ–≤–Ω–æ–º—É —Å–∞–π—Ç—ñ";
      else mpStatusEl.textContent = "–ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä: –≤–∏ " + (currentUserName || "–ì—Ä–∞–≤–µ—Ü—å");

      mpListEl.innerHTML = "";
      if (remoteStates.size === 0){
        const d=document.createElement("div");
        d.textContent="–ù–µ–º–∞—î —ñ–Ω—à–∏—Ö –≥—Ä–∞–≤—Ü—ñ–≤ —É –≥—Ä—ñ";
        mpListEl.appendChild(d);
        return;
      }

      remoteStates.forEach((data, uid)=>{
        const row=document.createElement("div");
        row.className="playerRow";
        const name=document.createElement("div");
        name.textContent = `${data.name} —É –≥—Ä—ñ`;
        const btn=document.createElement("button");
        btn.textContent="–ü—Ä–∏—î–¥–Ω–∞—Ç–∏—Å—è";
        btn.onclick=()=>joinToPlayer(uid);
        row.appendChild(name); row.appendChild(btn);
        mpListEl.appendChild(row);
      });
    }

    function syncGamePlayer(){
      if (!currentUserUid || !currentUserName) return;
      const ref = db.collection("gamePlayers").doc(currentUserUid);
      return ref.set({
        name: currentUserName,
        x: player.x,
        y: player.y,
        dir: player.dir,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge:true }).catch(err => console.error("–ü–æ–º–∏–ª–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó –≥—Ä–∞–≤—Ü—è:", err));
    }

    function maybeSyncGamePlayer(){
      if (!currentUserUid || !currentUserName) return;
      const now = performance.now();
      if (now - lastSyncTime < SYNC_INTERVAL) return;
      lastSyncTime = now;
      syncGamePlayer();
    }

    db.collection("gamePlayers").onSnapshot((snapshot)=>{
      remoteStates.clear();

      const nowMs = Date.now();
      remotePlayers.forEach(p=>p._seen=false);

      snapshot.forEach((docSnap)=>{
        const uid = docSnap.id;
        if (uid === currentUserUid) return;

        const data = docSnap.data() || {};
        const updatedAt = data.updatedAt?.toDate ? data.updatedAt.toDate().getTime() : 0;

        if (!updatedAt || nowMs - updatedAt > MAX_INACTIVE_MS){
          remotePlayers.delete(uid);
          return;
        }

        const name = data.name || "–ì—Ä–∞–≤–µ—Ü—å";
        const x = data.x ?? 0;
        const y = data.y ?? 2;
        const dir = data.dir ?? 0;

        remoteStates.set(uid, { name, x, y, dir });

        let rp = remotePlayers.get(uid);
        if (!rp){
          const h = hashUid(uid);
          const color = (h % 3 === 0) ? "green" : "blue";
          rp = { name, x, y, tx:x, ty:y, dir, tdir:dir, color, _seen:true };
          remotePlayers.set(uid, rp);
        } else {
          rp.name = name;
          rp.tx = x; rp.ty = y;
          rp.tdir = dir;
          rp._seen = true;
        }
      });

      for(const [uid, rp] of remotePlayers){
        if (!rp._seen) remotePlayers.delete(uid);
        else delete rp._seen;
      }

      updateMpUI();
    }, (err)=>console.error("–ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è gamePlayers:", err));

    auth.onAuthStateChanged((user)=>{
      if (user && user.displayName){
        currentUserUid = user.uid;
        currentUserName = user.displayName;
      } else {
        currentUserUid = null;
        currentUserName = null;
      }
      updateMpUI();
    });

    /* =========================
       MAIN LOOP
    ========================= */
    function worldToVisible(x,y,camx,camy){
      const halfW = INTERNAL_W/(2*PPU);
      const halfH = INTERNAL_H/(2*PPU);
      return !(x < camx-halfW-20 || x > camx+halfW+20 || y < camy-halfH-20 || y > camy+halfH+20);
    }

    let last = performance.now();

    function update(dt, time){
      updateDayNight(dt);

      if (isFrozen){
        updateSnow(dt);
        return;
      }

      let mx=0,my=0;
      if (keys["KeyW"] || keys["ArrowUp"]) my -= 1;
      if (keys["KeyS"] || keys["ArrowDown"]) my += 1;
      if (keys["KeyA"] || keys["ArrowLeft"]) mx -= 1;
      if (keys["KeyD"] || keys["ArrowRight"]) mx += 1;

      if (Math.abs(touchMoveX)>0.05 || Math.abs(touchMoveY)>0.05){
        mx += touchMoveX;
        my += touchMoveY;
      }

      // –Ω–∞–ø—Ä—è–º: –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω—ñ = –Ω–∞–ø—Ä—è–º —Ä—É—Ö—É, –Ω–∞ –ü–ö = –º–∏—à–∫–∞ (—è–∫—â–æ —Ä—É—Ö—É –º–∞–ª–æ)
      const len = Math.hypot(mx,my);
      if (len>0.001){
        mx/=len; my/=len;
        player.dir = Math.atan2(my,mx);
      } else if (mouseAim){
        const cx=innerWidth/2, cy=innerHeight/2;
        const dx=mouseAim.x - cx;
        const dy=mouseAim.y - cy;
        if (Math.hypot(dx,dy)>10) player.dir = Math.atan2(dy,dx);
      }

      const speed = 7.6;
      if (len>0.001){
        let nx = clamp(player.x + mx*speed*dt, -WORLD_HALF+1, WORLD_HALF-1);
        let ny = player.y;
        if (!isBlocked(nx, ny, player.r)) player.x = nx;

        nx = player.x;
        ny = clamp(player.y + my*speed*dt, -WORLD_HALF+1, WORLD_HALF-1);
        if (!isBlocked(nx, ny, player.r)) player.y = ny;
      }

      if (player.attackCooldown>0) player.attackCooldown -= dt;
      if (player.attack>0){
        player.attack += dt*3.2;
        if (player.attack>=1) player.attack=0;
      }

      for(const t of trees){
        if (t.falling && !t.removed){
          t.fallT += dt;
          if (t.fallT >= 0.75) t.removed = true;
        }
      }
      trees = trees.filter(t=>!t.removed);

      for(const b of buttons){
        if (b.flash>0) b.flash -= dt;
      }

      for(const h of houses) if (h.restored && h.restoreT<1) h.restoreT = Math.min(1, h.restoreT + dt*1.6);
      for(const f of farms)  if (f.restored && f.restoreT<1) f.restoreT = Math.min(1, f.restoreT + dt*1.6);
      for(const p of paths)  if (p.restored && p.restoreT<1) p.restoreT = Math.min(1, p.restoreT + dt*1.8);

      for(const pt of particles){
        pt.life -= dt;
        pt.x += pt.vx*dt;
        pt.y += pt.vy*dt;
        pt.vx *= 0.90;
        pt.vy *= 0.90;
        if (pt.type==="chips") pt.vy += 6.5*dt;
        if (pt.type==="restore") pt.vy -= 2.0*dt;
      }
      for(let i=particles.length-1;i>=0;i--) if (particles[i].life<=0) particles.splice(i,1);

      const d = Math.sqrt(dist2(player.x,player.y,campfire.x,campfire.y));
      const warmRadius=12;
      const coolRate=0.025;
      const warmRate=2.0;

      if (d<warmRadius){
        const factor=1-d/warmRadius;
        heatValue += warmRate*factor*dt;
      } else heatValue -= coolRate*dt;

      heatValue = clamp(heatValue, 0, heatMax);
      updateHeat();

      if (!isFrozen && heatValue<=0.01){
        isFrozen=true;
        freezeOverlay.style.opacity="1";
        freezeText.style.opacity="1";
      }

      camera.x = lerp(camera.x, player.x, 0.12);
      camera.y = lerp(camera.y, player.y, 0.12);

      for(const rp of remotePlayers.values()){
        rp.x = lerp(rp.x, rp.tx, 0.22);
        rp.y = lerp(rp.y, rp.ty, 0.22);
        let da = (rp.tdir - rp.dir);
        while (da > Math.PI) da -= Math.PI*2;
        while (da < -Math.PI) da += Math.PI*2;
        rp.dir += da*0.22;
      }

      updateSnow(dt);
      maybeSyncGamePlayer();
    }

    function render(time){
      bctx.fillStyle = groundPattern;
      bctx.fillRect(0,0,INTERNAL_W,INTERNAL_H);

      // paths
      for(const p of paths) if (worldToVisible(p.x,p.y,camera.x,camera.y)) drawPath(bctx,p);
      // farms
      for(const f of farms) if (worldToVisible(f.x,f.y,camera.x,camera.y)) drawFarm(bctx,f);
      // houses
      for(const h of houses) if (worldToVisible(h.x,h.y,camera.x,camera.y)) drawHouse(bctx,h,time);
      // rocks
      for(const r of rocks) if (worldToVisible(r.x,r.y,camera.x,camera.y)) drawRock(bctx,r);
      // mountains
      for(const m of mountains) if (worldToVisible(m.x,m.y,camera.x,camera.y)) drawMountain(bctx,m);
      // trees
      for(const t of trees) if (worldToVisible(t.x,t.y,camera.x,camera.y)) drawTree(bctx,t);

      drawCampfire(bctx,time);

      for(const b of buttons) if (worldToVisible(b.x,b.y,camera.x,camera.y)) drawButton(bctx,b,time);

      for(const pt of particles){
        const p = worldToScreen(pt.x,pt.y);
        const a = clamp(pt.life/0.75,0,1);
        bctx.fillStyle = pt.type==="chips" ? `rgba(180,120,70,${0.85*a})` : `rgba(110,255,170,${0.75*a})`;
        bctx.fillRect((p.x|0),(p.y|0),2,2);
      }

      for(const rp of remotePlayers.values()){
        if (worldToVisible(rp.x,rp.y,camera.x,camera.y)) drawRemotePlayer(bctx,rp,time);
      }

      drawPlayer(bctx,player,time);

      const night = 1 - light;
      if (night > 0.001){
        bctx.fillStyle = `rgba(10,20,40,${0.10 + 0.55*night})`;
        bctx.fillRect(0,0,INTERNAL_W,INTERNAL_H);
      }

      const screenW = innerWidth, screenH = innerHeight;
      const scale = Math.max(1, Math.floor(Math.min(screenW/INTERNAL_W, screenH/INTERNAL_H)));
      const drawW = INTERNAL_W*scale, drawH = INTERNAL_H*scale;
      const ox = ((screenW - drawW)/2)|0;
      const oy = ((screenH - drawH)/2)|0;

      gctx.clearRect(0,0,screenW,screenH);
      gctx.imageSmoothingEnabled = false;
      gctx.drawImage(buffer, 0,0,INTERNAL_W,INTERNAL_H, ox,oy, drawW,drawH);

      updateMinimap();
    }

    function loop(now){
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;
      const time = now/1000;
      update(dt,time);
      render(time);
      requestAnimationFrame(loop);
    }

    /* =========================
       Start
    ========================= */
    resize();
    initSnow(150);
    updateMpUI();
    requestAnimationFrame(loop);

    window.addEventListener("resize", ()=>{ resize(); initSnow(snowflakes.length||150); });
  })();
  </script>
</body>
</html>
