<html lang="uk"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" /> <title>Village ‚Äì 2D Snow Survival (Pixel)</title> <style> html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; font-family: "Segoe UI", Arial, sans-serif; touch-action:none; } #game { position:fixed; inset:0; width:100%; height:100%; image-rendering:pixelated; image-rendering:crisp-edges; } #fxCanvas { position:fixed; inset:0; width:100%; height:100%; pointer-events:none; z-index:8; } #info{ position:fixed; top:10px; left:10px; z-index:20; padding:8px 12px; background:rgba(0,0,0,0.55); color:#fff; font-size:13px; border-radius:12px; max-width:min(640px, calc(100vw - 20px)); box-shadow:0 10px 25px rgba(0,0,0,0.35); } #stats{ position:fixed; top:78px; left:10px; z-index:20; padding:6px 10px; background:rgba(0,0,0,0.55); color:#fff; font-size:13px; border-radius:12px; box-shadow:0 10px 25px rgba(0,0,0,0.35); } #heatBar{ position:fixed; bottom:18px; left:50%; transform:translateX(-50%); z-index:20; padding:6px 10px; background:rgba(0,0,0,0.55); color:#fff; font-size:18px; border-radius:14px; letter-spacing:2px; user-select:none; box-shadow:0 10px 25px rgba(0,0,0,0.35); } #minimap{ position:fixed; right:14px; top:14px; width:170px; height:170px; z-index:22; border-radius:16px; overflow:hidden; border:3px solid rgba(255,255,255,0.75); background:#0f260f; box-shadow:0 10px 25px rgba(0,0,0,0.35); } #minimapCanvas{ width:100%; height:100%; image-rendering:pixelated; } #mpToggle{ position:fixed; right:14px; top:194px; z-index:23; border:none; border-radius:14px; padding:10px 12px; background:rgba(0,0,0,0.60); color:#fff; cursor:pointer; box-shadow:0 10px 25px rgba(0,0,0,0.35); font-size:14px; font-weight:800; } #mpPanel{ position:fixed; right:14px; top:240px; width:220px; max-height:260px; overflow:auto; background:rgba(0,0,0,0.62); color:#fff; padding:10px; font-size:12px; border-radius:14px; z-index:22; box-shadow:0 10px 25px rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.08); } #mpStatus{ font-weight:900; margin-bottom:8px; } #mpList .playerRow{ margin-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.15); padding-bottom:8px; } #mpList .playerRow:last-child{ border-bottom:none; } #mpList button{ width:100%; margin-top:6px; border:none; padding:8px 10px; border-radius:12px; background:#3498db; color:#fff; cursor:pointer; font-size:12px; font-weight:800; } #freezeOverlay{ position:fixed; inset:0; background:#000; opacity:0; pointer-events:none; z-index:50; transition:opacity 1s; } #freezeText{ position:fixed; inset:0; display:grid; place-items:center; z-index:51; pointer-events:none; opacity:0; transition:opacity 1s; color:#fff; text-align:center; padding:24px; font-weight:900; } #freezeText .card{ background:rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.12); border-radius:16px; padding:14px 16px; max-width:520px; box-shadow:0 10px 25px rgba(0,0,0,0.35); } #errBox{ position:fixed; left:10px; right:10px; bottom:10px; z-index:99; background:rgba(120,0,0,0.80); color:#fff; padding:10px 12px; border-radius:12px; font: 12px/1.35 monospace; display:none; white-space:pre-wrap; border:1px solid rgba(255,255,255,0.18); } /* Touch: —Ç—ñ–ª—å–∫–∏ –õ–Ü–í–ò–ô –¥–∂–æ–π—Å—Ç–∏–∫ + –∫–Ω–æ–ø–∫–∞ —Å–æ–∫–∏—Ä–∏ */ #touchControls{ position:fixed; inset:0; pointer-events:none; z-index:30; display:none; } #touchControls .pad{ position:absolute; width:124px; height:124px; border-radius:50%; border:2px solid rgba(255,255,255,0.25); background:radial-gradient(circle, rgba(255,255,255,0.12) 0, rgba(0,0,0,0) 60%); pointer-events:auto; touch-action:none; backdrop-filter:blur(2px); } #movePad{ left:18px; bottom:28px; } #touchControls .stick{ position:absolute; width:60px; height:60px; border-radius:50%; left:32px; top:32px; background:rgba(46,204,113,0.82); box-shadow:0 0 14px rgba(46,204,113,0.95); } #actionBtn{ position:absolute; right:22px; bottom:22px; width:90px; height:90px; border-radius:50%; border:none; background:radial-gradient(circle, #ffb347 0, #e67e22 60%); box-shadow:0 0 18px rgba(230,126,34,0.95); font-size:36px; color:#fff; pointer-events:auto; touch-action:none; user-select:none; } @media (pointer:coarse){ #touchControls{ display:block; } #minimap{ width:128px; height:128px; right:10px; top:10px; border-radius:14px; } #mpToggle{ right:10px; top:148px; border-radius:14px; padding:10px 12px; } #mpPanel{ left:10px; right:10px; width:auto; top:auto; bottom:120px; max-height:220px; } #info{ font-size:12px; } #stats{ top:72px; } } </style> </head> <body> <div id="info"> –ü–ö: WASD ‚Äì —Ä—É—Ö, –º–∏—à–∫–∞ ‚Äì –Ω–∞–ø—Ä—è–º, –õ–ö–ú ‚Äì ü™ì –¥—ñ—è/—Ä—É–±–∫–∞/–∫–Ω–æ–ø–∫–∞<br> –¢–µ–ª–µ—Ñ–æ–Ω: –ª—ñ–≤–∏–π –∫—Ä—É–≥ ‚Äì —Ä—É—Ö, ü™ì ‚Äì –¥—ñ—è/—Ä—É–±–∫–∞/–∫–Ω–æ–ø–∫–∞ </div> <div id="stats"></div> <div id="heatBar"></div> <!-- Day/Night music (–∫—Ä–æ—Å—Ñ–µ–π–¥) --> <audio id="bgmDay" src="https://cdn.pixabay.com/audio/2022/03/15/audio_d542afd1d9.mp3" loop></audio> <audio id="bgmNight" src="https://cdn.pixabay.com/audio/2022/10/25/audio_8ed9eaa0d4.mp3" loop></audio> <div id="minimap"><canvas id="minimapCanvas" width="180" height="180"></canvas></div> <button id="mpToggle">üë• –î—Ä—É–∑—ñ</button> <div id="mpPanel"> <div id="mpStatus">–ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä: –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div> <div id="mpList"></div> </div> <canvas id="game"></canvas> <canvas id="fxCanvas"></canvas> <div id="touchControls"> <div id="movePad" class="pad"><div id="moveStick" class="stick"></div></div> <button id="actionBtn">ü™ì</button> </div> <div id="freezeOverlay"></div> <div id="freezeText"> <div class="card"> ‚ùÑÔ∏è –í–∏ –∑–∞–º–µ—Ä–∑–ª–∏‚Ä¶<br><br> –ü—ñ–¥—ñ–π–¥—ñ—Ç—å –±–ª–∏–∂—á–µ –¥–æ –≤–æ–≥–Ω–∏—â–∞, –ø–æ–∫–∏ —à–∫–∞–ª–∞ —Ç–µ–ø–ª–∞ –Ω–µ –≤–ø–∞–ª–∞ –¥–æ –Ω—É–ª—è.<br> (–©–æ–± –ø–æ—á–∞—Ç–∏ –∑–∞–Ω–æ–≤–æ ‚Äì –æ–Ω–æ–≤–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É) </div> </div> <div id="errBox"></div> <!-- Firebase compat --> <script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-app-compat.js"></script> <script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-auth-compat.js"></script> <script src="https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore-compat.js"></script> <script> (function(){ const errBox = document.getElementById("errBox"); function showErr(msg){ errBox.style.display="block"; errBox.textContent = msg; } window.addEventListener("error", (e)=> showErr("JS ERROR:\n" + (e.message || e.error || e))); window.addEventListener("unhandledrejection", (e)=> showErr("PROMISE ERROR:\n" + (e.reason?.message || e.reason || e))); const isCoarse = matchMedia("(pointer:coarse)").matches; /* Firebase */ const firebaseConfig = { apiKey: "AIzaSyDZEwAbFwLQXxlkkmuMKBFof2J3OE02Egs", authDomain: "pine-tycoon.firebaseapp.com", projectId: "pine-tycoon", storageBucket: "pine-tycoon.firebasestorage.app", messagingSenderId: "949986190236", appId: "1:949986190236:web:4f5d50078326f5c1981e59", measurementId: "G-2DY6KSY4G7" }; firebase.initializeApp(firebaseConfig); const auth = firebase.auth(); const db = firebase.firestore(); /* DOM */ const statsEl = document.getElementById("stats"); const heatEl = document.getElementById("heatBar"); const freezeOverlay = document.getElementById("freezeOverlay"); const freezeText = document.getElementById("freezeText"); const mpStatusEl = document.getElementById("mpStatus"); const mpListEl = document.getElementById("mpList"); const mpPanel = document.getElementById("mpPanel"); const mpToggle = document.getElementById("mpToggle"); const gameCanvas = document.getElementById("game"); const gctx = gameCanvas.getContext("2d"); const fxCanvas = document.getElementById("fxCanvas"); const fx = fxCanvas.getContext("2d"); const mini = document.getElementById("minimapCanvas"); const mctx = mini.getContext("2d"); /* Audio: day/night crossfade */ const dayBgm = document.getElementById("bgmDay"); const nightBgm = document.getElementById("bgmNight"); dayBgm.volume = 0; nightBgm.volume = 0; let actx=null; let audioUnlocked=false; function ensureAudio(){ if (audioUnlocked) return; audioUnlocked = true; try{ const AudioCtx = window.AudioContext || window.webkitAudioContext; actx = new AudioCtx(); if (actx.state === "suspended") actx.resume().catch(()=>{}); }catch(e){ actx=null; } dayBgm.play().catch(()=>{}); nightBgm.play().catch(()=>{}); } window.addEventListener("pointerdown", ensureAudio, { once:true }); window.addEventListener("touchstart", ensureAudio, { once:true }); function playTone({freq=220, dur=0.08, type="sine", vol=0.18, slideTo=null}){ if (!actx) return; const t0 = actx.currentTime; const o = actx.createOscillator(); const g = actx.createGain(); o.type = type; o.frequency.setValueAtTime(freq, t0); if (slideTo != null) o.frequency.exponentialRampToValueAtTime(Math.max(20, slideTo), t0 + dur); g.gain.setValueAtTime(vol, t0); g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur); o.connect(g).connect(actx.destination); o.start(t0); o.stop(t0 + dur + 0.02); } function playNoise({dur=0.09, vol=0.12}){ if (!actx) return; const sr = actx.sampleRate; const len = Math.floor(sr * dur); const buf = actx.createBuffer(1, len, sr); const data = buf.getChannelData(0); for(let i=0;i<len;i++){ const t = i/len; data[i] = (Math.random()*2-1) * (1 - t) * 0.9; } const src = actx.createBufferSource(); src.buffer = buf; const g = actx.createGain(); g.gain.value = vol; const f = actx.createBiquadFilter(); f.type="highpass"; f.frequency.value=800; src.connect(f).connect(g).connect(actx.destination); src.start(); src.stop(actx.currentTime + dur + 0.02); } const SFX = { swing(){ ensureAudio(); playTone({freq:280, slideTo:160, dur:0.08, type:"triangle", vol:0.12}); }, chop(){ ensureAudio(); playNoise({dur:0.07, vol:0.10}); playTone({freq:120, dur:0.05, type:"sine", vol:0.08}); }, restore(){ ensureAudio(); playTone({freq:340, slideTo:760, dur:0.12, type:"sine", vol:0.11}); }, error(){ ensureAudio(); playTone({freq:180, slideTo:120, dur:0.10, type:"square", vol:0.07}); }, crack(){ ensureAudio(); playNoise({dur:0.10, vol:0.08}); playTone({freq:95, dur:0.08, type:"sine", vol:0.07}); } }; /* Helpers */ const clamp = (v,a,b)=>Math.max(a,Math.min(b,v)); const lerp = (a,b,t)=>a+(b-a)*t; const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }; const rand = (a,b)=> a + Math.random()*(b-a); function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); } function easeOutQuint(t){ return 1 - Math.pow(1-t, 5); } /* Pixel buffer */ const INTERNAL_W = 512; const INTERNAL_H = 288; const buffer = document.createElement("canvas"); buffer.width = INTERNAL_W; buffer.height = INTERNAL_H; const bctx = buffer.getContext("2d"); bctx.imageSmoothingEnabled = false; gctx.imageSmoothingEnabled = false; /* World */ const WORLD_HALF = 160; const PPU = 16; /* Colliders */ const colliders = []; function addColliderRect(x,y,hw,hh, tag=""){ const r = { x,y,hw,hh,tag }; colliders.push(r); return r; } function circleRectCollide(px,py,pr,r){ const cx = clamp(px, r.x - r.hw, r.x + r.hw); const cy = clamp(py, r.y - r.hh, r.y + r.hh); const dx = px - cx, dy = py - cy; return dx*dx + dy*dy <= pr*pr; } function isBlocked(px,py,pr){ return colliders.some(r => circleRectCollide(px,py,pr,r)); } /* Colors */ const COL = { snow:"#f5f9ff", snow2:"#e9f1ff", shadow:"rgba(0,0,0,0.35)", path:"#b38a5d", path2:"#a67c52", soil:"#5b3a1a", rock:"#7f8894", rock2:"#5f6772", mtn:"#6a707a", mtn2:"#52585f", btn:"#32d26c", btnGlow:"rgba(50,210,108,0.55)", blue:"#2d6cdf", blue2:"#68a0ff", green:"#1dbb5a", flame:"#ff6b2a", flame2:"#ffd35a", tree:"#3e7f4b", tree2:"#5fb26c", tree3:"#2f6a3b" // <<< –¥–µ—Ä–µ–≤–æ –∑–µ–ª–µ–Ω—ñ—à–µ, —â–æ–± –Ω–µ –∑–ª–∏–≤–∞–ª–æ—Å—è –∑—ñ —Å–Ω—ñ–≥–æ–º }; const groundPattern = (() => { const c = document.createElement("canvas"); c.width = 64; c.height = 64; const x = c.getContext("2d"); x.fillStyle = COL.snow; x.fillRect(0,0,64,64); for(let i=0;i<150;i++){ const px=(Math.random()*64)|0, py=(Math.random()*64)|0; x.fillStyle = Math.random()<0.6 ? COL.snow2 : "#ffffff"; x.fillRect(px,py,1,1); } return bctx.createPattern(c, "repeat"); })(); /* Entities */ const houses = []; const farms = []; const paths = []; const rocks = []; const mountains = []; const lamps = []; let trees = []; let buttons = []; const campfire = { x:0, y:30 }; function createRestoreButton(x,y,cost,type,target){ buttons.push({ x,y,cost,type,target, restored:false, phase:Math.random()*Math.PI*2, flash:0 }); } function mkHouseVariant(i){ const variants = [ { walls:"#9a6a3d", walls2:"#7c4f2b", roof:"#c84d3a", roof2:"#a73a2a", chimney:true }, { walls:"#7d5c3a", walls2:"#5a3f28", roof:"#3d6fb3", roof2:"#2e568f", chimney:false }, { walls:"#b07d4f", walls2:"#8a5a33", roof:"#3a3a3a", roof2:"#242424", chimney:true }, { walls:"#8b8b8b", walls2:"#6f6f6f", roof:"#a63b2f", roof2:"#7f2a22", chimney:false } ]; return variants[i % variants.length]; } function createHouse(x,y, vi=0){ const v = mkHouseVariant(vi); const h = { kind:"small", x,y, w:6, h:6, restored:false, restoreT:0, v, cost:45 }; houses.push(h); createRestoreButton(x, y+4.2, h.cost, "house", h); } function createBigHouse(x,y, vi=1){ const v = mkHouseVariant(vi); const h = { kind:"big", x,y, w:7, h:7, restored:false, restoreT:0, v, cost:65 }; houses.push(h); createRestoreButton(x, y+4.8, h.cost, "bigHouse", h); } function createFarm(x,y,w,l, cropType=0){ const f = { x,y,w,l, restored:false, restoreT:0, cropType, cost:15 }; farms.push(f); createRestoreButton(x, y + l/2 + 1.2, f.cost, "farm", f); } function createPath(x,y,w,l){ const p = { x,y,w,l, restored:false, restoreT:0, cost:5 }; paths.push(p); createRestoreButton(x,y,p.cost,"path",p); } function createLamp(x,y){ lamps.push({ x,y, flick: Math.random()*10 }); addColliderRect(x,y, 0.45, 0.45, "lamp"); } function createRock(x,y,size){ rocks.push({ x,y,size }); addColliderRect(x,y, size*0.9, size*0.9, "rock"); } function createMountain(x,y){ const base = 8 + Math.random()*6; const height = 10 + Math.random()*8; mountains.push({ x,y,base,height }); addColliderRect(x,y, base*0.85, base*0.85, "mountain"); } function createMountainsBorder(){ for(let x=-150;x<=150;x+=15){ createMountain(x,-150); createMountain(x,150); } for(let y=-150;y<=150;y+=15){ createMountain(-150,y); createMountain(150,y); } for(let i=0;i<35;i++){ const a=Math.random()*Math.PI*2; const r=110 + Math.random()*25; createMountain(Math.cos(a)*r, Math.sin(a)*r); } } function createTree(x,y){ const kind = (Math.random()*3)|0; const scale = rand(0.85, 1.25); const snowiness = rand(0.35, 0.9); // –º–µ–Ω—à–µ ‚Äú–±—ñ–ª–æ—ó —è–ª–∏–Ω–∫–∏‚Äù const trunk = rand(0.9, 1.35); const baseHP = 3 + (Math.random()<0.25 ? 1 : 0); // —à–≤–∏–¥—à–µ —Ä—É–±–∞—é—Ç—å—Å—è const t = { x,y, hp: baseHP, falling:false, fallT:0, fallDir: Math.random()<0.5 ? -1 : 1, removed:false, collider:null, kind, scale, snowiness, trunk }; t.collider = addColliderRect(x,y, 0.85, 0.85, "tree"); trees.push(t); } function forestRing(cx,cy, inner, outer, count){ for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const r=inner + Math.random()*(outer-inner); const x=cx + Math.cos(a)*r; const y=cy + Math.sin(a)*r; if (Math.sqrt(x*x+y*y) < 20) continue; createTree(x,y); } } function createForestRocks(count){ for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const r=30 + Math.random()*70; const x=Math.cos(a)*r; const y=Math.sin(a)*r; if (Math.sqrt(x*x+y*y) < 25){ i--; continue; } createRock(x,y, 0.8 + Math.random()*1.4); } } function buildVillage(){ // —Ä–æ–∑–≤–µ–¥–µ–Ω–æ, —â–æ–± –Ω–µ ‚Äú–≤‚Äô—ó–∂–¥–∂–∞–ª–∏‚Äù –æ–¥–∏–Ω –≤ –æ–¥–Ω–æ–≥–æ createHouse( 0, 0, 0); createHouse( 20, -8, 1); createHouse(-22, 10, 2); createHouse( 4, -24, 3); createHouse( 28, 16, 0); createHouse(-30, -16, 1); createHouse( 40, 2, 2); createHouse(-40, -2, 3); createHouse( 14, 30, 1); createHouse(-14, -32, 0); createBigHouse( 32, -30, 2); createBigHouse(-34, 30, 3); createPath(0,-8, 4,20); createPath(0, 8, 4,20); createPath(8,0, 20,4); createPath(-8,0, 20,4); createPath(20,-14, 16,4); createPath(-20,14, 16,4); createFarm( 0, -40, 12, 7, 0); createFarm( 28, 8, 11, 7, 1); createFarm(-28, -8, 11, 7, 2); // –õ—ñ—Ö—Ç–∞—Ä—ñ (—Å–≤—ñ—Ç—è—Ç—å —É–Ω–æ—á—ñ) createLamp( 0, 12); createLamp( 0, -12); createLamp( 12, 0); createLamp(-12, 0); createLamp( 22, -14); createLamp(-22, 14); } buildVillage(); forestRing(0,0,24,42,95); forestRing(0,0,42,70,130); forestRing(0,0,70,100,170); createForestRocks(30); createMountainsBorder(); /* Stats/heat */ let treesCutTotal = 0; let wood = 0; const heatMax = 9; let heatValue = heatMax; let isFrozen = false; function updateStats(){ statsEl.textContent = –î–µ—Ä–µ–≤ –∑—Ä—É–±–∞–Ω–æ: ${treesCutTotal} | –î–µ—Ä–µ–≤–æ: ${wood}; } function updateHeat(){ const full = Math.round(heatValue); let s=""; for (let i=0;i<heatMax;i++) s += i<full ? "üî•" : "¬∑"; heatEl.textContent = s; } updateStats(); updateHeat(); /* Player/camera */ const player = { x:0, y:35, r:0.60, dir:-Math.PI/2, attack:0, attackCooldown:0 }; const camera = { x:player.x, y:player.y }; /* Day/Night */ const SWITCH_EVERY = 300; // 5 —Ö–≤ const TRANSITION = 14; let dayNightTimer = 0; let isNight = false; let light = 1; let fromLight = 1, toLight = 1, transT = 1; function updateDayNight(dt){ dayNightTimer += dt; if (dayNightTimer >= SWITCH_EVERY){ dayNightTimer -= SWITCH_EVERY; isNight = !isNight; fromLight = light; toLight = isNight ? 0 : 1; transT = 0; } if (transT < 1){ transT = Math.min(1, transT + dt/TRANSITION); light = lerp(fromLight, toLight, easeOutQuint(transT)); } // –º—É–∑–∏–∫–∞ (–∫—Ä–æ—Å—Ñ–µ–π–¥) if (audioUnlocked){ const base = 0.36; dayBgm.volume = base * light; nightBgm.volume = base * (1 - light); } } /* Particles */ const particles = []; function spawnParticles(type,x,y,count=10){ for (let i=0;i<count;i++){ const a=Math.random()*Math.PI*2; const sp=rand(1.8,6.0); particles.push({ type, x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(0.35,0.75) }); } } /* Controls */ const keys = {}; document.addEventListener("keydown",(e)=>keys[e.code]=true); document.addEventListener("keyup",(e)=>keys[e.code]=false); let mouseAim = null; window.addEventListener("mousemove",(e)=>{ mouseAim={x:e.clientX,y:e.clientY}; }); window.addEventListener("mouseleave",()=>{ mouseAim=null; }); const movePad = document.getElementById("movePad"); const moveStick = document.getElementById("moveStick"); const actionBtn = document.getElementById("actionBtn"); let touchMoveX=0, touchMoveY=0; function setupMoveStick(pad, stick){ const stickRadius=30; let touchId=null; function reset(){ const rect=pad.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; stick.style.left=(cx-stickRadius)+"px"; stick.style.top =(cy-stickRadius)+"px"; touchMoveX=0; touchMoveY=0; } function updateFromTouch(t){ const rect=pad.getBoundingClientRect(); const cx=rect.width/2, cy=rect.height/2; let dx=t.clientX - (rect.left+cx); let dy=t.clientY - (rect.top +cy); const maxR=rect.width/2 - stickRadius; const d=Math.hypot(dx,dy); if (d>maxR){ dx*=maxR/d; dy*=maxR/d; } stick.style.left=(cx-stickRadius+dx)+"px"; stick.style.top =(cy-stickRadius+dy)+"px"; touchMoveX=dx/maxR; touchMoveY=dy/maxR; } pad.addEventListener("touchstart",(e)=>{ e.preventDefault(); const t=e.changedTouches[0]; touchId=t.identifier; updateFromTouch(t); },{passive:false}); pad.addEventListener("touchmove",(e)=>{ e.preventDefault(); if (touchId===null) return; for (const t of e.touches){ if (t.identifier===touchId){ updateFromTouch(t); break; } } },{passive:false}); function end(e){ if (touchId===null) return; for (const t of e.changedTouches){ if (t.identifier===touchId){ touchId=null; reset(); break; } } } pad.addEventListener("touchend", end, {passive:false}); pad.addEventListener("touchcancel", end, {passive:false}); reset(); } if (movePad && moveStick) setupMoveStick(movePad, moveStick); /* Axe cooldown (—Ç—Ä–æ—Ö–∏ —à–≤–∏–¥—à–µ) */ const AXE_COOLDOWN = 0.38; function doAction(){ if (isFrozen) return; ensureAudio(); if (player.attackCooldown > 0) return; player.attack = 0.0001; player.attackCooldown = AXE_COOLDOWN; SFX.swing(); const used = tryUseNearestButton(); if (!used) chopNearestTree(); } window.addEventListener("mousedown",(e)=>{ if(e.button===0) doAction(); }); if (actionBtn){ const tap=(e)=>{ e.preventDefault(); doAction(); }; actionBtn.addEventListener("click", tap); actionBtn.addEventListener("touchstart", tap, {passive:false}); } function tryUseNearestButton(){ let best=null, bestD=(2.2*2.2); for (const b of buttons){ if (b.restored) continue; const d=dist2(player.x,player.y,b.x,b.y); if (d<bestD){ bestD=d; best=b; } } if (!best) return false; if (wood < best.cost){ best.flash = 0.22; SFX.error(); return true; } wood -= best.cost; best.restored = true; if (best.type==="house" || best.type==="bigHouse"){ best.target.restored = true; best.target.restoreT = 0.0001; addColliderRect( best.target.x, best.target.y, best.type==="bigHouse" ? 4.2 : 3.2, best.type==="bigHouse" ? 4.2 : 3.2, "house" ); } else if (best.type==="farm"){ best.target.restored = true; best.target.restoreT = 0.0001; addColliderRect(best.target.x, best.target.y, best.target.w/2, best.target.l/2, "farm"); } else if (best.type==="path"){ best.target.restored = true; best.target.restoreT = 0.0001; } spawnParticles("restore", best.x, best.y, 18); SFX.restore(); buttons = buttons.filter(x=>x!==best); updateStats(); return true; } function chopNearestTree(){ let best=null, bestD=(3.2*3.2); // —Ç—Ä–æ—Ö–∏ –±—ñ–ª—å—à–∞ –¥–∏—Å—Ç–∞–Ω—Ü—ñ—è for (const t of trees){ if (t.falling || t.removed) continue; const d=dist2(player.x,player.y,t.x,t.y); if (d<bestD){ bestD=d; best=t; } } if (!best) return; best.hp -= 1; spawnParticles("chips", best.x, best.y, 12); SFX.chop(); if (best.hp<=0 && !best.falling){ best.falling=true; best.fallT=0; const idx=colliders.indexOf(best.collider); if (idx!==-1) colliders.splice(idx,1); treesCutTotal++; wood++; updateStats(); SFX.crack(); } } /* Render helpers */ function worldToScreen(wx,wy){ const sx=(wx-camera.x)*PPU + INTERNAL_W/2; const sy=(wy-camera.y)*PPU + INTERNAL_H/2; return { x:sx, y:sy }; } function drawShadowCircle(ctx,x,y,r){ ctx.fillStyle = COL.shadow; ctx.beginPath(); ctx.ellipse(x,y,r*1.1,r*0.7,0,0,Math.PI*2); ctx.fill(); } function pRect(ctx,x,y,w,h){ ctx.fillRect((x|0),(y|0),(w|0),(h|0)); } function drawAxe(ctx,x,y, ang, swing){ ctx.save(); ctx.translate(x,y); ctx.rotate(ang + swing); ctx.fillStyle = "#7c4f2b"; pRect(ctx, -1, -10, 2, 18); ctx.fillStyle = "#c3c9d3"; pRect(ctx, 0, -7, 11, 6); ctx.fillStyle = "#9aa2ad"; pRect(ctx, 0, -7, 11, 2); ctx.restore(); } function drawPlayer(ctx, p, time){ const pos = worldToScreen(p.x,p.y); const bob = Math.sin(time*6)*0.8; drawShadowCircle(ctx, pos.x, pos.y + 10, 14); ctx.fillStyle = COL.blue; ctx.beginPath(); ctx.arc(pos.x, pos.y + bob, 10, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = COL.blue2; ctx.beginPath(); ctx.arc(pos.x - 3, pos.y - 3 + bob, 4, 0, Math.PI*2); ctx.fill(); const atk = p.attack>0 ? Math.sin(p.attack*Math.PI) : 0; const swing = -0.95*atk; const axeX = pos.x + Math.cos(p.dir)*14; const axeY = pos.y + Math.sin(p.dir)*10 + bob; drawAxe(ctx, axeX, axeY, p.dir + Math.PI/2, swing); } function drawRemotePlayer(ctx, rp, time){ const pos = worldToScreen(rp.x,rp.y); drawShadowCircle(ctx, pos.x, pos.y + 10, 14); ctx.fillStyle = rp.color === "green" ? "rgba(29,187,90,0.58)" : "rgba(45,108,223,0.55)"; ctx.beginPath(); ctx.arc(pos.x, pos.y, 10, 0, Math.PI*2); ctx.fill(); const axeX = pos.x + Math.cos(rp.dir)*14; const axeY = pos.y + Math.sin(rp.dir)*10; drawAxe(ctx, axeX, axeY, rp.dir + Math.PI/2, 0); ctx.font = "bold 12px Segoe UI, Arial"; ctx.textAlign = "center"; ctx.textBaseline = "bottom"; ctx.fillStyle = "rgba(0,0,0,0.35)"; ctx.fillText(rp.name, pos.x+1, pos.y - 14 + 1); ctx.fillStyle = "#ffffff"; ctx.fillText(rp.name, pos.x, pos.y - 14); } function drawTree(ctx, t){ const pos = worldToScreen(t.x,t.y); // –ø–∞–¥—ñ–Ω–Ω—è –¥–µ—Ä–µ–≤–∞ –ø–ª–∞–≤–Ω—ñ—à–µ const fallDur = 0.78; const k = t.falling ? clamp(t.fallT/fallDur, 0, 1) : 0; const kk = easeOutQuint(k); const ang = t.falling ? (kk * (Math.PI/2) * t.fallDir) : 0; const s = t.scale; const trunkH = PPU*(0.95*t.trunk)*s; drawShadowCircle(ctx, pos.x, pos.y + PPU*0.38, PPU*0.72*s); ctx.save(); ctx.translate(pos.x, pos.y); if (t.falling){ ctx.translate(kk * PPU*0.65 * t.fallDir, kk * PPU*0.12); } ctx.translate(0, PPU*0.25*s); ctx.rotate(ang); ctx.translate(0, -PPU*0.25*s); ctx.fillStyle = "#6b4625"; pRect(ctx, -2*s, -trunkH*0.15, 4*s, trunkH); const snowA = t.snowiness; const greenA = 1 - snowA; // –∑–µ–ª–µ–Ω–∞ —Ö–≤–æ—è + —Å–Ω—ñ–∂–Ω—ñ ‚Äú–ø—ñ–¥—Å–≤—ñ—Ç–∫–∏‚Äù const base = rgba(62,127,75,${0.95*greenA + 0.10}); const hi = rgba(95,178,108,${0.75*greenA + 0.10}); const snow1 = rgba(233,241,255,${0.45*snowA}); const snow2 = rgba(245,249,255,${0.65*snowA}); function coneTri(topY, wY, wX){ ctx.fillStyle = base; ctx.beginPath(); ctx.moveTo(0, topY); ctx.lineTo(wX, wY); ctx.lineTo(-wX, wY); ctx.closePath(); ctx.fill(); ctx.fillStyle = hi; ctx.beginPath(); ctx.moveTo(0, topY); ctx.lineTo(0, wY); ctx.lineTo(-wX, wY); ctx.closePath(); ctx.fill(); ctx.fillStyle = snow2; ctx.beginPath(); ctx.moveTo(0, topY + PPU*0.12*s); ctx.lineTo(wX*0.60, wY - PPU*0.10*s); ctx.lineTo(-wX*0.60, wY - PPU*0.10*s); ctx.closePath(); ctx.fill(); ctx.fillStyle = snow1; ctx.beginPath(); ctx.moveTo(0, topY + PPU*0.32*s); ctx.lineTo(wX*0.45, wY - PPU*0.30*s); ctx.lineTo(-wX*0.45, wY - PPU*0.30*s); ctx.closePath(); ctx.fill(); } if (t.kind === 0){ coneTri(-PPU*1.65*s, -PPU*0.10*s, PPU*1.05*s); coneTri(-PPU*1.25*s, -PPU*0.30*s, PPU*0.85*s); } else if (t.kind === 1){ coneTri(-PPU*1.55*s, -PPU*0.25*s, PPU*1.20*s); ctx.fillStyle = base; ctx.beginPath(); ctx.arc(0, -PPU*0.75*s, PPU*0.70*s, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = snow1; ctx.beginPath(); ctx.arc(0, -PPU*0.85*s, PPU*0.52*s, 0, Math.PI*2); ctx.fill(); } else { coneTri(-PPU*1.80*s, -PPU*0.05*s, PPU*0.95*s); coneTri(-PPU*1.10*s, -PPU*0.25*s, PPU*0.75*s); } ctx.restore(); } function drawLamp(ctx, l, time){ const pos = worldToScreen(l.x,l.y); drawShadowCircle(ctx, pos.x, pos.y + 10, 10); // —Å—Ç–æ–≤–ø ctx.fillStyle = "rgba(60,60,70,0.95)"; pRect(ctx, pos.x-1, pos.y-20, 2, 26); // –ª—ñ—Ö—Ç–∞—Ä ctx.fillStyle = "rgba(30,30,40,0.95)"; pRect(ctx, pos.x-6, pos.y-26, 12, 10); const night = 1 - light; if (night > 0.02){ const flick = 0.9 + Math.sin(time*6 + l.flick)*0.12; ctx.fillStyle = rgba(255,230,170,${0.55*night*flick}); pRect(ctx, pos.x-4, pos.y-24, 8, 6); const g = ctx.createRadialGradient(pos.x, pos.y-22, 6, pos.x, pos.y-22, 70); g.addColorStop(0, rgba(255,210,120,${0.22*night*flick})); g.addColorStop(1, "rgba(0,0,0,0)"); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(pos.x, pos.y-22, 70, 0, Math.PI*2); ctx.fill(); } } function drawCampfire(ctx, time){ const pos = worldToScreen(campfire.x, campfire.y); for (let i=0;i<6;i++){ const a = i*(Math.PI/3); const px = pos.x + Math.cos(a)*PPU*1.0; const py = pos.y + Math.sin(a)*PPU*0.75; ctx.fillStyle = COL.rock2; ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill(); } const night = 1 - light; const flick = 1 + Math.sin(time*10)*0.18; drawShadowCircle(ctx, pos.x, pos.y + 8, 12); // –ø–æ–ª—É–º'—è (–±—ñ–ª—å—à–µ/—è—Å–∫—Ä–∞–≤—ñ—à–µ) ctx.fillStyle = COL.flame; ctx.beginPath(); ctx.moveTo(pos.x, pos.y - 22*flick); ctx.quadraticCurveTo(pos.x + 12, pos.y - 6, pos.x, pos.y + 12); ctx.quadraticCurveTo(pos.x - 12, pos.y - 6, pos.x, pos.y - 22*flick); ctx.fill(); ctx.fillStyle = COL.flame2; ctx.beginPath(); ctx.moveTo(pos.x, pos.y - 14*flick); ctx.quadraticCurveTo(pos.x + 9, pos.y - 3, pos.x, pos.y + 9); ctx.quadraticCurveTo(pos.x - 9, pos.y - 3, pos.x, pos.y - 14*flick); ctx.fill(); // —è—Å–∫—Ä–∞–≤—ñ—à–µ —Å–≤—ñ—Ç–ª–æ const g = ctx.createRadialGradient(pos.x, pos.y, 14, pos.x, pos.y, 92); g.addColorStop(0, rgba(255,120,60,${0.28 + 0.25*night})); g.addColorStop(1, "rgba(0,0,0,0)"); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(pos.x, pos.y, 92, 0, Math.PI*2); ctx.fill(); } function drawButton(ctx, b, time){ const pos = worldToScreen(b.x,b.y); const pulse = 1 + Math.sin(time*5 + b.phase)*0.10; drawShadowCircle(ctx, pos.x, pos.y + 10, 14); ctx.fillStyle = COL.btn; ctx.beginPath(); ctx.ellipse(pos.x, pos.y, 14*pulse, 10*pulse, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = COL.btnGlow; ctx.beginPath(); ctx.ellipse(pos.x, pos.y, 20*pulse, 14*pulse, 0, 0, Math.PI*2); ctx.fill(); ctx.font = "900 14px Segoe UI, Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = (b.flash>0) ? "#ff4d4d" : "#ffffff"; ctx.fillText(String(b.cost), pos.x, pos.y - 18); } // –ë—É–¥–∏–Ω–∫–∏ –∫—Ä–∞—Å–∏–≤—ñ—à—ñ (–æ–±‚Äô—î–º, –∫–∞—Ä–Ω–∏–∑, –¥–∞—Ö-—á–µ—Ä–µ–ø–∏—Ü—è) function drawHouse(ctx, h, time){ const v = h.v; const fade = h.restored ? (0.45 + 0.55*easeOutCubic(h.restoreT)) : 0.38; const pos = worldToScreen(h.x,h.y); const w = h.w*PPU, l = h.h*PPU; drawShadowCircle(ctx, pos.x, pos.y + l*0.18, Math.max(w,l)*0.25); ctx.globalAlpha = fade; // –∫–æ—Ä–ø—É—Å –∑ –ª–µ–≥–∫–∏–º ‚Äú–æ–±‚Äô—î–º–æ–º‚Äù ctx.fillStyle = v.walls; pRect(ctx, pos.x - w/2, pos.y - l/2, w, l); ctx.fillStyle = "rgba(255,255,255,0.07)"; pRect(ctx, pos.x - w/2 + 3, pos.y - l/2 + 3, w*0.55, l-6); ctx.fillStyle = "rgba(0,0,0,0.12)"; pRect(ctx, pos.x + w*0.18, pos.y - l/2 + 2, w*0.32, l-4); // –∫–∞—Ä–Ω–∏–∑ ctx.fillStyle = "rgba(0,0,0,0.22)"; pRect(ctx, pos.x - w/2, pos.y - l/2, w, 3); // –¥–∞—Ö const roofH = (h.kind==="big") ? PPU*2.5 : PPU*2.15; ctx.fillStyle = v.roof; ctx.beginPath(); ctx.moveTo(pos.x, pos.y - l/2 - roofH); ctx.lineTo(pos.x + w/2 + 2, pos.y - l/2 + PPU*0.9); ctx.lineTo(pos.x, pos.y - l/2 + PPU*2.6); ctx.lineTo(pos.x - w/2 - 2, pos.y - l/2 + PPU*0.9); ctx.closePath(); ctx.fill(); ctx.fillStyle = v.roof2; ctx.beginPath(); ctx.moveTo(pos.x, pos.y - l/2 - roofH); ctx.lineTo(pos.x, pos.y - l/2 + PPU*2.6); ctx.lineTo(pos.x - w/2 - 2, pos.y - l/2 + PPU*0.9); ctx.closePath(); ctx.fill(); // ‚Äú—á–µ—Ä–µ–ø–∏—Ü—è‚Äù ctx.fillStyle = "rgba(0,0,0,0.12)"; for (let i=0;i<6;i++){ const yy = pos.y - l/2 + PPU*0.95 + i*2; pRect(ctx, pos.x - w/2, yy, w, 1); } if (v.chimney){ ctx.fillStyle = "#3b3b3b"; pRect(ctx, pos.x + w*0.18, pos.y - l/2 - roofH*0.6, PPU*0.55, PPU*1.2); } // –¥–≤–µ—Ä—ñ + “ë–∞–Ω–æ–∫ ctx.fillStyle = v.walls2; pRect(ctx, pos.x - PPU*0.95, pos.y + l*0.12, PPU*1.9, PPU*2.4); ctx.fillStyle = "rgba(0,0,0,0.22)"; pRect(ctx, pos.x - PPU*1.4, pos.y + l*0.36, PPU*2.8, 2); // –≤—ñ–∫–Ω–∞ + —Å–≤—ñ—Ç–ª–æ const night = 1 - light; const windowGlow = h.restored ? (0.15 + 0.85*night) : 0.12; ctx.fillStyle = rgba(255,230,160,${0.35*windowGlow}); pRect(ctx, pos.x - PPU*2.2, pos.y - PPU*0.2, PPU*1.25, PPU*1.25); ctx.fillStyle = rgba(255,230,160,${0.45*windowGlow}); pRect(ctx, pos.x + PPU*1.2, pos.y - PPU*0.2, PPU*1.25, PPU*1.25); if (h.restored && night > 0.02){ const g = ctx.createRadialGradient(pos.x, pos.y, 8, pos.x, pos.y, 62); g.addColorStop(0, rgba(255,210,120,${0.20*night})); g.addColorStop(1, "rgba(0,0,0,0)"); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(pos.x, pos.y, 62, 0, Math.PI*2); ctx.fill(); } ctx.globalAlpha = 1; } function drawFarm(ctx, f){ const fade = f.restored ? (0.45 + 0.55*easeOutCubic(f.restoreT)) : 0.38; const pos = worldToScreen(f.x,f.y); const w = f.w*PPU, l = f.l*PPU; drawShadowCircle(ctx, pos.x, pos.y + l*0.22, Math.max(w,l)*0.20); ctx.globalAlpha = fade; ctx.fillStyle = COL.soil; pRect(ctx, pos.x - w/2, pos.y - l/2, w, l); ctx.fillStyle = "rgba(0,0,0,0.18)"; for (let r=0;r<5;r++){ const yy = pos.y - l/2 + (r+0.5)*(l/5); pRect(ctx, pos.x - w/2 + 2, yy, w-4, 1); } for (let row=0; row<4; row++){ for (let col=0; col<Math.floor(f.w); col++){ const cx = pos.x - w/2 + (col+0.5)*PPU; const cy = pos.y - l/2 + (row+0.65)*(l/4); if (f.cropType === 0){ ctx.fillStyle = "rgba(255,244,200,0.86)"; pRect(ctx, cx-1, cy-3, 2, 6); ctx.fillStyle = "rgba(180,140,70,0.45)"; pRect(ctx, cx-2, cy+3, 4, 1); } else if (f.cropType === 1){ ctx.fillStyle = "rgba(120,255,170,0.85)"; pRect(ctx, cx-1, cy-3, 2, 4); ctx.fillStyle = "rgba(255,160,90,0.85)"; pRect(ctx, cx-1, cy+1, 2, 2); } else { ctx.fillStyle = "rgba(230,245,255,0.9)"; pRect(ctx, cx-2, cy-2, 4, 4); ctx.fillStyle = "rgba(0,0,0,0.15)"; pRect(ctx, cx-2, cy+2, 4, 1); } } } ctx.globalAlpha = 1; } function drawPath(ctx, p){ const fade = p.restored ? (0.48 + 0.52*easeOutCubic(p.restoreT)) : 0.35; const pos = worldToScreen(p.x,p.y); const w = p.w*PPU, l = p.l*PPU; ctx.globalAlpha = fade; ctx.fillStyle = COL.path; pRect(ctx, pos.x - w/2, pos.y - l/2, w, l); ctx.fillStyle = COL.path2; for (let i=0;i<10;i++){ const tx = pos.x - w/2 + Math.random()*w; const ty = pos.y - l/2 + Math.random()*l; pRect(ctx, tx, ty, 2, 2); } ctx.globalAlpha = 1; } function drawRock(ctx, r){ const pos = worldToScreen(r.x,r.y); const s = r.size*PPU; drawShadowCircle(ctx, pos.x, pos.y + s*0.22, s*0.55); ctx.fillStyle = COL.rock; ctx.beginPath(); ctx.moveTo(pos.x - s*0.6, pos.y); ctx.lineTo(pos.x - s*0.2, pos.y - s*0.45); ctx.lineTo(pos.x + s*0.55, pos.y - s*0.1); ctx.lineTo(pos.x + s*0.35, pos.y + s*0.50); ctx.lineTo(pos.x - s*0.35, pos.y + s*0.45); ctx.closePath(); ctx.fill(); ctx.fillStyle = COL.rock2; ctx.beginPath(); ctx.moveTo(pos.x - s*0.2, pos.y - s*0.45); ctx.lineTo(pos.x + s*0.15, pos.y - s*0.30); ctx.lineTo(pos.x + s*0.55, pos.y - s*0.1); ctx.lineTo(pos.x + s*0.05, pos.y - s*0.05); ctx.closePath(); ctx.fill(); } function drawMountain(ctx, m){ const pos = worldToScreen(m.x,m.y); const base = m.base*PPU; const h = m.height*PPU; drawShadowCircle(ctx, pos.x, pos.y + base*0.25, base*0.80); ctx.fillStyle = COL.mtn; ctx.beginPath(); ctx.moveTo(pos.x, pos.y - h*0.55); ctx.lineTo(pos.x + base*0.65, pos.y + base*0.50); ctx.lineTo(pos.x - base*0.65, pos.y + base*0.50); ctx.closePath(); ctx.fill(); ctx.fillStyle = COL.mtn2; ctx.beginPath(); ctx.moveTo(pos.x, pos.y - h*0.55); ctx.lineTo(pos.x, pos.y + base*0.50); ctx.lineTo(pos.x - base*0.65, pos.y + base*0.50); ctx.closePath(); ctx.fill(); ctx.fillStyle = COL.snow2; ctx.beginPath(); ctx.moveTo(pos.x, pos.y - h*0.55); ctx.lineTo(pos.x + base*0.18, pos.y - h*0.30); ctx.lineTo(pos.x, pos.y - h*0.18); ctx.lineTo(pos.x - base*0.20, pos.y - h*0.30); ctx.closePath(); ctx.fill(); } /* Minimap */ const remoteStates = new Map(); function updateMinimap(){ mctx.clearRect(0,0,mini.width,mini.height); mctx.fillStyle="#132e13"; mctx.fillRect(0,0,mini.width,mini.height); const scale = mini.width/(WORLD_HALF*2); const toM=(wx,wy)=>({ x:(wx+WORLD_HALF)*scale, y:(wy+WORLD_HALF)*scale }); // —Ä–∞–º–∫–∞ mctx.strokeStyle="rgba(255,255,255,0.20)"; mctx.lineWidth=2; mctx.strokeRect(1,1,mini.width-2,mini.height-2); // –∫–æ–ª—ñ–∑—ñ—ó —Ç–æ—á–∫–∞–º–∏ mctx.fillStyle="rgba(80,255,120,0.55)"; for (const c of colliders){ const p=toM(c.x,c.y); mctx.fillRect(p.x|0, p.y|0, 2, 2); } // –≤–æ–≥–Ω–∏—â–µ const cf=toM(campfire.x,campfire.y); mctx.fillStyle="rgba(255,160,90,0.9)"; mctx.beginPath(); mctx.arc(cf.x, cf.y, 3, 0, Math.PI*2); mctx.fill(); // —ñ–Ω—à—ñ –≥—Ä–∞–≤—Ü—ñ remoteStates.forEach((d)=>{ const p=toM(d.x,d.y); mctx.fillStyle="rgba(90,160,255,0.85)"; mctx.fillRect((p.x|0)-1,(p.y|0)-1,3,3); }); // —Ç–∏ const mp=toM(player.x,player.y); mctx.save(); mctx.translate(mp.x, mp.y); mctx.rotate(player.dir); mctx.fillStyle="#ffffff"; mctx.beginPath(); mctx.moveTo(0,-6); mctx.lineTo(4,4); mctx.lineTo(-4,4); mctx.closePath(); mctx.fill(); mctx.restore(); } /* Snow FX (–≥–æ–ª—É–±—ñ) */ let snowflakes=[]; function resize(){ const dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1)); gameCanvas.width = Math.floor(innerWidth*dpr); gameCanvas.height= Math.floor(innerHeight*dpr); gctx.setTransform(dpr,0,0,dpr,0,0); fxCanvas.width = Math.floor(innerWidth*dpr); fxCanvas.height= Math.floor(innerHeight*dpr); fx.setTransform(dpr,0,0,dpr,0,0); } function initSnow(count=150){ snowflakes=[]; for (let i=0;i<count;i++){ snowflakes.push({ x:Math.random()*innerWidth, y:Math.random()*innerHeight, r:1 + Math.random()*1.8, speed:24 + Math.random()*40, drift:-12 + Math.random()*22 }); } } function updateSnow(dt){ fx.clearRect(0,0,innerWidth,innerHeight); const night = 1 - light; fx.fillStyle = rgba(170,220,255,${0.85 - 0.15*night}); // –≥–æ–ª—É–±—ñ for (const f of snowflakes){ f.y += f.speed*dt; f.x += f.drift*dt; if (f.y > innerHeight + f.r){ f.y=-f.r; f.x=Math.random()*innerWidth; } if (f.x < -10) f.x=innerWidth+10; if (f.x > innerWidth+10) f.x=-10; fx.beginPath(); fx.arc(f.x,f.y,f.r,0,Math.PI*2); fx.fill(); } } /* Multiplayer */ let currentUserUid=null; let currentUserName=null; const remotePlayers = new Map(); const MAX_INACTIVE_MS = 30000; let lastSyncTime = 0; const SYNC_INTERVAL = 220; // —Ç—Ä–æ—Ö–∏ —Ä—ñ–¥—à–µ ‚Üí –ª–µ–≥—à–µ –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω—É function hashUid(uid){ let h=0; for (let i=0;i<uid.length;i++) h = (h*31 + uid.charCodeAt(i))|0; return Math.abs(h); } function joinToPlayer(uid){ const data = remoteStates.get(uid); if (!data) return; player.x = data.x + 2; player.y = data.y + 2; player.dir = data.dir ?? player.dir; } let mpOpen = true; function setMpOpen(v){ mpOpen = v; mpPanel.style.display = mpOpen ? "block" : "none"; mpToggle.textContent = mpOpen ? "üë• –î—Ä—É–∑—ñ" : "üë•"; } mpToggle.addEventListener("click", ()=> setMpOpen(!mpOpen)); if (isCoarse) setMpOpen(false); function updateMpUI(){ if (!currentUserUid) mpStatusEl.textContent = "–ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä: —É–≤—ñ–π–¥—ñ—Ç—å —É –∞–∫–∞—É–Ω—Ç –Ω–∞ –≥–æ–ª–æ–≤–Ω–æ–º—É —Å–∞–π—Ç—ñ"; else mpStatusEl.textContent = "–ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä: –≤–∏ " + (currentUserName || "–ì—Ä–∞–≤–µ—Ü—å"); mpListEl.innerHTML = ""; if (remoteStates.size === 0){ const d=document.createElement("div"); d.textContent="–ù–µ–º–∞—î —ñ–Ω—à–∏—Ö –≥—Ä–∞–≤—Ü—ñ–≤ —É –≥—Ä—ñ"; mpListEl.appendChild(d); return; } remoteStates.forEach((data, uid)=>{ const row=document.createElement("div"); row.className="playerRow"; const name=document.createElement("div"); name.textContent = ${data.name} —É –≥—Ä—ñ; const btn=document.createElement("button"); btn.textContent="–ü—Ä–∏—î–¥–Ω–∞—Ç–∏—Å—è"; btn.onclick=()=>joinToPlayer(uid); row.appendChild(name); row.appendChild(btn); mpListEl.appendChild(row); }); } function syncGamePlayer(){ if (!currentUserUid || !currentUserName) return; const ref = db.collection("gamePlayers").doc(currentUserUid); return ref.set({ name: currentUserName, x: player.x, y: player.y, dir: player.dir, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge:true }).catch(err => console.error("–ü–æ–º–∏–ª–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó –≥—Ä–∞–≤—Ü—è:", err)); } function maybeSyncGamePlayer(){ if (!currentUserUid || !currentUserName) return; const now = performance.now(); if (now - lastSyncTime < SYNC_INTERVAL) return; lastSyncTime = now; syncGamePlayer(); } db.collection("gamePlayers").onSnapshot((snapshot)=>{ remoteStates.clear(); const nowMs = Date.now(); remotePlayers.forEach(p=>p._seen=false); snapshot.forEach((docSnap)=>{ const uid = docSnap.id; if (uid === currentUserUid) return; const data = docSnap.data() || {}; const updatedAt = data.updatedAt?.toDate ? data.updatedAt.toDate().getTime() : 0; if (!updatedAt || nowMs - updatedAt > MAX_INACTIVE_MS){ remotePlayers.delete(uid); return; } const name = data.name || "–ì—Ä–∞–≤–µ—Ü—å"; const x = data.x ?? 0; const y = data.y ?? 2; const dir = data.dir ?? 0; remoteStates.set(uid, { name, x, y, dir }); let rp = remotePlayers.get(uid); if (!rp){ const h = hashUid(uid); const color = (h % 3 === 0) ? "green" : "blue"; rp = { name, x, y, tx:x, ty:y, dir, tdir:dir, color, _seen:true }; remotePlayers.set(uid, rp); } else { rp.name = name; rp.tx = x; rp.ty = y; rp.tdir = dir; rp._seen = true; } }); for (const [uid, rp] of remotePlayers){ if (!rp._seen) remotePlayers.delete(uid); else delete rp._seen; } updateMpUI(); }, (err)=>console.error("–ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è gamePlayers:", err)); auth.onAuthStateChanged((user)=>{ if (user && user.displayName){ currentUserUid = user.uid; currentUserName = user.displayName; } else { currentUserUid = null; currentUserName = null; } updateMpUI(); }); /* Loop */ function worldToVisible(x,y,camx,camy){ const halfW = INTERNAL_W/(2*PPU); const halfH = INTERNAL_H/(2*PPU); return !(x < camx-halfW-20 || x > camx+halfW+20 || y < camy-halfH-20 || y > camy+halfH+20); } let last = performance.now(); function update(dt, time){ updateDayNight(dt); if (isFrozen){ updateSnow(dt); return; } let mx=0,my=0; if (keys["KeyW"] || keys["ArrowUp"]) my -= 1; if (keys["KeyS"] || keys["ArrowDown"]) my += 1; if (keys["KeyA"] || keys["ArrowLeft"]) mx -= 1; if (keys["KeyD"] || keys["ArrowRight"]) mx += 1; if (Math.abs(touchMoveX)>0.05 || Math.abs(touchMoveY)>0.05){ mx += touchMoveX; my += touchMoveY; } const len = Math.hypot(mx,my); // ‚úÖ –ü–ö: –Ω–∞–ø—Ä—è–º –ó–ê–í–ñ–î–ò –≤—ñ–¥ –º–∏—à–∫–∏ (—è–∫—â–æ —î –º–∏—à–∫–∞) if (!isCoarse && mouseAim){ const cx=innerWidth/2, cy=innerHeight/2; const dx=mouseAim.x - cx; const dy=mouseAim.y - cy; if (Math.hypot(dx,dy)>6) player.dir = Math.atan2(dy,dx); } else if (len>0.001){ // –¢–µ–ª–µ—Ñ–æ–Ω: –Ω–∞–ø—Ä—è–º = –Ω–∞–ø—Ä—è–º —Ä—É—Ö—É player.dir = Math.atan2(my, mx); } const speed = 7.8; if (len>0.001){ const nx = clamp(player.x + (mx/Math.max(1,len))*speed*dt, -WORLD_HALF+1, WORLD_HALF-1); if (!isBlocked(nx, player.y, player.r)) player.x = nx; const ny = clamp(player.y + (my/Math.max(1,len))*speed*dt, -WORLD_HALF+1, WORLD_HALF-1); if (!isBlocked(player.x, ny, player.r)) player.y = ny; } if (player.attackCooldown>0) player.attackCooldown -= dt; if (player.attack>0){ player.attack += dt*3.2; if (player.attack>=1) player.attack=0; } for (const t of trees){ if (t.falling && !t.removed){ t.fallT += dt; if (t.fallT >= 0.85) t.removed = true; } } trees = trees.filter(t=>!t.removed); for (const b of buttons) if (b.flash>0) b.flash -= dt; for (const h of houses) if (h.restored && h.restoreT<1) h.restoreT = Math.min(1, h.restoreT + dt*1.6); for (const f of farms) if (f.restored && f.restoreT<1) f.restoreT = Math.min(1, f.restoreT + dt*1.6); for (const p of paths) if (p.restored && p.restoreT<1) p.restoreT = Math.min(1, p.restoreT + dt*1.8); for (const pt of particles){ pt.life -= dt; pt.x += pt.vx*dt; pt.y += pt.vy*dt; pt.vx *= 0.90; pt.vy *= 0.90; if (pt.type==="chips") pt.vy += 6.5*dt; if (pt.type==="restore") pt.vy -= 2.0*dt; } for (let i=particles.length-1;i>=0;i--) if (particles[i].life<=0) particles.splice(i,1); const d = Math.sqrt(dist2(player.x,player.y,campfire.x,campfire.y)); const warmRadius=12; const coolRate=0.025; const warmRate=2.1; if (d<warmRadius){ const factor=1-d/warmRadius; heatValue += warmRate*factor*dt; } else heatValue -= coolRate*dt; heatValue = clamp(heatValue, 0, heatMax); updateHeat(); if (!isFrozen && heatValue<=0.01){ isFrozen=true; freezeOverlay.style.opacity="1"; freezeText.style.opacity="1"; } camera.x = lerp(camera.x, player.x, 0.12); camera.y = lerp(camera.y, player.y, 0.12); for (const rp of remotePlayers.values()){ rp.x = lerp(rp.x, rp.tx, 0.22); rp.y = lerp(rp.y, rp.ty, 0.22); let da = (rp.tdir - rp.dir); while (da > Math.PI) da -= Math.PI*2; while (da < -Math.PI) da += Math.PI*2; rp.dir += da*0.22; } updateSnow(dt); maybeSyncGamePlayer(); } function render(time){ bctx.fillStyle = groundPattern; bctx.fillRect(0,0,INTERNAL_W,INTERNAL_H); for (const p of paths) if (worldToVisible(p.x,p.y,camera.x,camera.y)) drawPath(bctx,p); for (const f of farms) if (worldToVisible(f.x,f.y,camera.x,camera.y)) drawFarm(bctx,f); for (const h of houses) if (worldToVisible(h.x,h.y,camera.x,camera.y)) drawHouse(bctx,h,time); for (const r of rocks) if (worldToVisible(r.x,r.y,camera.x,camera.y)) drawRock(bctx,r); for (const m of mountains) if (worldToVisible(m.x,m.y,camera.x,camera.y)) drawMountain(bctx,m); for (const t of trees) if (worldToVisible(t.x,t.y,camera.x,camera.y)) drawTree(bctx,t); drawCampfire(bctx,time); for (const l of lamps) if (worldToVisible(l.x,l.y,camera.x,camera.y)) drawLamp(bctx,l,time); for (const b of buttons) if (worldToVisible(b.x,b.y,camera.x,camera.y)) drawButton(bctx,b,time); for (const pt of particles){ const p = worldToScreen(pt.x,pt.y); const a = clamp(pt.life/0.75,0,1); bctx.fillStyle = pt.type==="chips" ? rgba(180,120,70,${0.85*a}) : rgba(110,255,170,${0.75*a}); bctx.fillRect((p.x|0),(p.y|0),2,2); } for (const rp of remotePlayers.values()){ if (worldToVisible(rp.x,rp.y,camera.x,camera.y)) drawRemotePlayer(bctx,rp,time); } drawPlayer(bctx,player,time); // –Ω—ñ—á–Ω–∞ ‚Äú–≤—É–∞–ª—å‚Äù + —Ç—Ä–æ—Ö–∏ –º‚Äô—è–∫—à–∞ const night = 1 - light; if (night > 0.001){ bctx.fillStyle = rgba(10,20,40,${0.08 + 0.52*night}); bctx.fillRect(0,0,INTERNAL_W,INTERNAL_H); } const screenW = innerWidth, screenH = innerHeight; const scale = Math.max(1, Math.floor(Math.min(screenW/INTERNAL_W, screenH/INTERNAL_H))); const drawW = INTERNAL_W*scale, drawH = INTERNAL_H*scale; const ox = ((screenW - drawW)/2)|0; const oy = ((screenH - drawH)/2)|0; gctx.clearRect(0,0,screenW,screenH); gctx.imageSmoothingEnabled = false; gctx.drawImage(buffer, 0,0,INTERNAL_W,INTERNAL_H, ox,oy, drawW,drawH); updateMinimap(); } function loop(now){ const dt = Math.min(0.033, (now - last)/1000); last = now; const time = now/1000; update(dt,time); render(time); requestAnimationFrame(loop); } /* Start */ resize(); initSnow(isCoarse ? 140 : 160); updateMpUI(); requestAnimationFrame(loop); window.addEventListener("resize", ()=>{ resize(); initSnow(snowflakes.length||150); }); })(); </script> </body> </html>
