<!doctype html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Village ‚Äì 2D Snow Survival (Pixel)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
    }

    /* –ì–æ–ª–æ–≤–Ω–∏–π 2D canvas */
    #game {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    /* FX canvas (—Å–Ω—ñ–≥/–æ–≤–µ—Ä–ª–µ—ó) */
    #fxCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 8;
    }

    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 13px;
      border-radius: 8px;
      z-index: 20;
      max-width: min(560px, calc(100vw - 20px));
    }

    #stats {
      position: fixed;
      top: 78px;
      left: 10px;
      padding: 6px 10px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 13px;
      border-radius: 8px;
      z-index: 20;
    }

    /* –®–∫–∞–ª–∞ —Ç–µ–ø–ª–∞ */
    #heatBar {
      position: fixed;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 10px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 18px;
      border-radius: 10px;
      z-index: 20;
      letter-spacing: 2px;
      user-select: none;
    }

    /* –ú—ñ–Ω—ñ–º–ø–∞ */
    #minimap {
      position: fixed;
      right: 16px;
      top: 16px;
      width: 180px;
      height: 180px;
      border-radius: 16px;
      overflow: hidden;
      z-index: 22;
      border: 3px solid rgba(255,255,255,0.75);
      background: #0f260f;
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    }
    #minimapCanvas {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
    }

    /* –ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä –ø–∞–Ω–µ–ª—å */
    #mpPanel {
      position: fixed;
      right: 16px;
      top: 212px;
      width: 210px;
      max-height: 260px;
      overflow-y: auto;
      background: rgba(0,0,0,0.60);
      color: #fff;
      padding: 8px;
      font-size: 12px;
      border-radius: 12px;
      z-index: 22;
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    }
    #mpStatus {
      font-weight: 700;
      margin-bottom: 8px;
    }
    #mpList .playerRow {
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      padding-bottom: 6px;
    }
    #mpList .playerRow:last-child { border-bottom: none; }
    #mpList button {
      width: 100%;
      margin-top: 4px;
      border: none;
      padding: 5px 7px;
      border-radius: 10px;
      background: #3498db;
      color: #fff;
      cursor: pointer;
      font-size: 12px;
    }
    #mpList button:hover { background: #2980b9; }

    /* –ó–∞–º–µ—Ä–∑–∞–Ω–Ω—è */
    #freezeOverlay {
      position: fixed;
      inset: 0;
      background: #000;
      opacity: 0;
      pointer-events: none;
      z-index: 50;
      transition: opacity 1s;
    }
    #freezeText {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 51;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s;
      color: #fff;
      text-align: center;
      padding: 24px;
      font-weight: 700;
    }
    #freezeText .card {
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 14px 16px;
      max-width: 520px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    }

    /* –¢–∞—á-–∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä */
    #touchControls {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 30;
      display: none;
    }
    #touchControls .pad {
      position: absolute;
      width: 124px;
      height: 124px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.25);
      background: radial-gradient(circle, rgba(255,255,255,0.12) 0, rgba(0,0,0,0) 60%);
      pointer-events: auto;
      touch-action: none;
      backdrop-filter: blur(2px);
    }
    #movePad { left: 18px; bottom: 28px; }
    #lookPad { right: 18px; bottom: 28px; }

    #touchControls .stick {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      left: 32px;
      top: 32px;
      background: rgba(46,204,113,0.82);
      box-shadow: 0 0 14px rgba(46,204,113,0.95);
    }

    #actionBtn {
      position: absolute;
      right: 30px;
      bottom: 148px;
      width: 74px;
      height: 74px;
      border-radius: 50%;
      border: none;
      background: radial-gradient(circle, #ffb347 0, #e67e22 60%);
      box-shadow: 0 0 16px rgba(230,126,34,0.95);
      font-size: 30px;
      color: #fff;
      pointer-events: auto;
      touch-action: none;
      user-select: none;
    }

    /* Tap-to-start –¥–ª—è –º—É–∑–∏–∫–∏ (–Ω–∞ iOS/Android —á–∞—Å—Ç–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ) */
    #tapStart {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      z-index: 60;
      background: rgba(0,0,0,0.55);
      color: #fff;
    }
    #tapStart .btn {
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.16);
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    }

    @media (pointer: coarse) {
      #touchControls { display: block; }
    }
  </style>
</head>
<body>

  <div id="info">
    –ü–ö: WASD/—Å—Ç—Ä—ñ–ª–∫–∏ ‚Äì —Ä—É—Ö, –º–∏—à–∫–∞ ‚Äì –Ω–∞–ø—Ä—è–º, –õ–ö–ú ‚Äì ü™ì –¥—ñ—è/—Ä—É–±–∫–∞/–∫–Ω–æ–ø–∫–∞<br>
    –¢–µ–ª–µ—Ñ–æ–Ω: –ª—ñ–≤–∏–π –∫—Ä—É–≥ ‚Äì —Ä—É—Ö, –ø—Ä–∞–≤–∏–π ‚Äì –Ω–∞–ø—Ä—è–º, ü™ì ‚Äì –¥—ñ—è/—Ä—É–±–∫–∞/–∫–Ω–æ–ø–∫–∞<br>
    –î—Ä—É–∑—ñ: —É–≤—ñ–π–¥—ñ—Ç—å —É –∞–∫–∞—É–Ω—Ç–∏ –Ω–∞ —Å–∞–π—Ç—ñ –π –≤—ñ–¥–∫—Ä–∏–π—Ç–µ —Ü—é —Å—Ç–æ—Ä—ñ–Ω–∫—É, —â–æ–± –±–∞—á–∏—Ç–∏ –æ–¥–∏–Ω –æ–¥–Ω–æ–≥–æ.
  </div>

  <div id="stats"></div>
  <div id="heatBar"></div>

  <audio id="bgm" src="https://cdn.pixabay.com/audio/2022/03/15/audio_d542afd1d9.mp3" loop></audio>

  <div id="minimap"><canvas id="minimapCanvas" width="180" height="180"></canvas></div>

  <div id="mpPanel">
    <div id="mpStatus">–ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä: –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>
    <div id="mpList"></div>
  </div>

  <canvas id="game"></canvas>
  <canvas id="fxCanvas"></canvas>

  <div id="touchControls">
    <div id="movePad" class="pad"><div id="moveStick" class="stick"></div></div>
    <div id="lookPad" class="pad"><div id="lookStick" class="stick"></div></div>
    <button id="actionBtn">ü™ì</button>
  </div>

  <div id="freezeOverlay"></div>
  <div id="freezeText">
    <div class="card">
      ‚ùÑÔ∏è –í–∏ –∑–∞–º–µ—Ä–∑–ª–∏‚Ä¶<br><br>
      –ü—ñ–¥—ñ–π–¥—ñ—Ç—å –±–ª–∏–∂—á–µ –¥–æ –≤–æ–≥–Ω–∏—â–∞, –ø–æ–∫–∏ —à–∫–∞–ª–∞ —Ç–µ–ø–ª–∞ –Ω–µ –≤–ø–∞–ª–∞ –¥–æ –Ω—É–ª—è.<br>
      (–©–æ–± –ø–æ—á–∞—Ç–∏ –∑–∞–Ω–æ–≤–æ ‚Äì –æ–Ω–æ–≤–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É)
    </div>
  </div>

  <div id="tapStart"><div class="btn">–ù–∞—Ç–∏—Å–Ω–∏, —â–æ–± –ø–æ—á–∞—Ç–∏ ‚ñ∂</div></div>

<script type="module">
/* =========================
   Firebase (—è–∫ —É —Ç–µ–±–µ)
========================= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
import {
  getFirestore,
  collection,
  doc,
  setDoc,
  onSnapshot,
  serverTimestamp
} from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyDZEwAbFwLQXxlkkmuMKBFof2J3OE02Egs",
  authDomain: "pine-tycoon.firebaseapp.com",
  projectId: "pine-tycoon",
  storageBucket: "pine-tycoon.firebasestorage.app",
  messagingSenderId: "949986190236",
  appId: "1:949986190236:web:4f5d50078326f5c1981e59",
  measurementId: "G-2DY6KSY4G7"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

/* =========================
   DOM
========================= */
const statsEl = document.getElementById("stats");
const heatEl  = document.getElementById("heatBar");
const freezeOverlay = document.getElementById("freezeOverlay");
const freezeText = document.getElementById("freezeText");

const mpStatusEl = document.getElementById("mpStatus");
const mpListEl = document.getElementById("mpList");

const gameCanvas = document.getElementById("game");
const gctx = gameCanvas.getContext("2d", { alpha: false });

const fxCanvas = document.getElementById("fxCanvas");
const fx = fxCanvas.getContext("2d");

const mini = document.getElementById("minimapCanvas");
const mctx = mini.getContext("2d");

/* =========================
   Tap to start audio
========================= */
const tapStart = document.getElementById("tapStart");
const music = document.getElementById("bgm");
music.volume = 0.42;

function unlockAudio() {
  tapStart.style.display = "none";
  music.play().catch(()=>{});
  window.removeEventListener("pointerdown", unlockAudio);
  window.removeEventListener("touchstart", unlockAudio);
}
window.addEventListener("pointerdown", unlockAudio, { once: true });
window.addEventListener("touchstart", unlockAudio, { once: true });
tapStart.addEventListener("click", unlockAudio);

/* =========================
   Helpers
========================= */
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a,b,t) => a + (b-a)*t;
const dist2 = (ax,ay,bx,by) => {
  const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy;
};
const rand = (a,b)=> a + Math.random()*(b-a);

function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }
function easeOutBack(t){
  const c1 = 1.70158, c3 = c1 + 1;
  return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2);
}

/* =========================
   Pixel –∫–∞–º–µ—Ä–∞ (–≤–Ω—É—Ç—Ä. —Ä–µ–Ω–¥–µ—Ä)
========================= */
const INTERNAL_W = 480;     // –≤–Ω—É—Ç—Ä—ñ—à–Ω—è "–ø—ñ–∫—Å–µ–ª—å–Ω–∞" —Ä–æ–∑–¥—ñ–ª—å–Ω–∞
const INTERNAL_H = 270;

const buffer = document.createElement("canvas");
buffer.width = INTERNAL_W;
buffer.height = INTERNAL_H;
const bctx = buffer.getContext("2d");

bctx.imageSmoothingEnabled = false;
gctx.imageSmoothingEnabled = false;

/* –†–æ–∑–º—ñ—Ä–∏ —Å–≤—ñ—Ç—É (–≤ "—é–Ωi—Ç–∞—Ö") */
const WORLD_HALF = 160;     // —è–∫ —Ç–≤–æ—è 320x320 –ø–ª–æ—â–∏–Ω–∞ –≤ 3D
const PPU = 16;             // pixels per unit —É –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ–º—É –±—É—Ñ–µ—Ä—ñ

/* =========================
   –°–≤—ñ—Ç: –∫–æ–ª–∞–π–¥–µ—Ä–∏/—Å—É—Ç–Ω–æ—Å—Ç—ñ
========================= */
const colliders = []; // rect: {x,y,hw,hh, tag}
function addColliderRect(x,y,hw,hh, tag="") {
  const r = { x, y, hw, hh, tag };
  colliders.push(r);
  return r;
}
function circleRectCollide(px,py,pr, r){
  const cx = clamp(px, r.x - r.hw, r.x + r.hw);
  const cy = clamp(py, r.y - r.hh, r.y + r.hh);
  const dx = px - cx, dy = py - cy;
  return dx*dx + dy*dy <= pr*pr;
}
function isBlocked(px,py, pr){
  return colliders.some(r => circleRectCollide(px,py,pr, r));
}

/* –°—É—Ç–Ω–æ—Å—Ç—ñ */
const houses = [];
const farms = [];
const paths = [];
const rocks = [];
const mountains = [];
let trees = [];
let buttons = [];

const campfire = { x: 0, y: 30 };

/* =========================
   –°—Ç–∏–ª—å/–∫–æ–ª—å–æ—Ä–∏
========================= */
const COL = {
  snow: "#f5f9ff",
  snow2:"#e9f1ff",
  shadow:"rgba(0,0,0,0.35)",
  path: "#b38a5d",
  path2:"#a67c52",
  wood1:"#9a6a3d",
  wood2:"#7c4f2b",
  roof1:"#c84d3a",
  roof2:"#a73a2a",
  soil:"#5b3a1a",
  crop:"#e9f6ff",
  rock:"#7f8894",
  rock2:"#5f6772",
  mtn:"#6a707a",
  mtn2:"#52585f",
  btn:"#32d26c",
  btnGlow:"rgba(50,210,108,0.55)",
  blue:"#2d6cdf",
  blue2:"#68a0ff",
  white:"#ffffff",
  black:"#000000",
  flame:"#ff6b2a",
  flame2:"#ffcc33"
};

/* –°–Ω—ñ–≥–æ–≤–∏–π –ø–∞—Ç–µ—Ä–Ω –¥–ª—è –∑–µ–º–ª—ñ */
const groundPattern = (() => {
  const c = document.createElement("canvas");
  c.width = 64; c.height = 64;
  const x = c.getContext("2d");
  x.fillStyle = COL.snow;
  x.fillRect(0,0,64,64);
  for(let i=0;i<120;i++){
    const px = (Math.random()*64)|0;
    const py = (Math.random()*64)|0;
    x.fillStyle = Math.random()<0.6 ? COL.snow2 : "#ffffff";
    x.fillRect(px,py,1,1);
  }
  return bctx.createPattern(c, "repeat");
})();

/* =========================
   –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Å–≤—ñ—Ç—É (—è–∫ —É 3D)
========================= */
function createRestoreButton(x,y,cost,type,target){
  buttons.push({
    x, y, cost, type, target,
    restored: false,
    phase: Math.random()*Math.PI*2,
    flash: 0
  });
}

function createHouse(x,y){
  const h = {
    type:"house",
    x,y,
    w: 6, h: 6,
    restored:false,
    restoreT:0
  };
  houses.push(h);
  createRestoreButton(x, y + 4.2, 45, "house", h);
}

function createBigHouse(x,y){
  const h = {
    type:"bigHouse",
    x,y,
    w: 7, h: 7,
    restored:false,
    restoreT:0
  };
  houses.push(h);
  createRestoreButton(x, y + 4.8, 65, "bigHouse", h);
}

function createFarm(x,y,w,l){
  const f = { x,y,w,l, restored:false, restoreT:0 };
  farms.push(f);
  createRestoreButton(x, y + l/2 + 1.2, 15, "farm", f);
}

function createPath(x,y,w,l){
  const p = { x,y,w,l, restored:false, restoreT:0 };
  paths.push(p);
  createRestoreButton(x, y, 5, "path", p);
}

function createRock(x,y,size){
  const r = { x,y,size };
  rocks.push(r);
  addColliderRect(x,y, size*0.9, size*0.9, "rock");
}

function createMountain(x,y){
  const base = 8 + Math.random()*6;
  const height = 10 + Math.random()*8;
  const m = { x,y, base, height };
  mountains.push(m);
  addColliderRect(x,y, base*0.85, base*0.85, "mountain");
}

function createMountainsBorder(){
  for(let x=-150; x<=150; x+=15){
    createMountain(x, -150);
    createMountain(x, 150);
  }
  for(let y=-150; y<=150; y+=15){
    createMountain(-150, y);
    createMountain(150, y);
  }
  for (let i=0;i<35;i++){
    const a = Math.random()*Math.PI*2;
    const r = 110 + Math.random()*25;
    createMountain(Math.cos(a)*r, Math.sin(a)*r);
  }
}

function createTree(x,y){
  const t = {
    x,y,
    hp: 4,
    falling:false,
    fallT:0,
    fallDir: Math.random()<0.5 ? -1 : 1,
    removed:false,
    collider: null
  };
  t.collider = addColliderRect(x,y, 0.85, 0.85, "tree");
  trees.push(t);
}

function forestRing(cx,cy, inner, outer, count){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const r = inner + Math.random()*(outer-inner);
    const x = cx + Math.cos(a)*r;
    const y = cy + Math.sin(a)*r;
    if (Math.sqrt(x*x+y*y) < 20) continue;
    createTree(x,y);
  }
}

function createForestRocks(count){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const r = 30 + Math.random()*70;
    const x = Math.cos(a)*r;
    const y = Math.sin(a)*r;
    if (Math.sqrt(x*x+y*y) < 25) { i--; continue; }
    const size = 0.8 + Math.random()*1.4;
    createRock(x,y,size);
  }
}

/* –°–µ–ª–æ */
createHouse(0,0);
createHouse(10,-6);
createHouse(-10,6);
createHouse(0,-14);
createHouse(14,10);
createHouse(-14,-10);
createHouse(20,0);
createHouse(-20,0);
createHouse(8,18);
createHouse(-8,-20);

createBigHouse(16,-20);
createBigHouse(-16,20);

createPath(0,-7,4,14);
createPath(0, 7,4,14);
createPath(7, 0,14,4);
createPath(-7,0,14,4);

createFarm(0,-22,10,6);
createFarm(18, 6,10,6);
createFarm(-18,-6,10,6);

forestRing(0,0,24,42,100);
forestRing(0,0,42,70,140);
forestRing(0,0,70,100,180);

createForestRocks(30);
createMountainsBorder();

/* =========================
   –ì—Ä–∞–≤–µ—Ü—å/—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞/—Ç–µ–ø–ª–æ
========================= */
let treesCutTotal = 0;
let wood = 0;

const heatMax = 9;
let heatValue = heatMax;
let isFrozen = false;

function updateStats(){
  statsEl.textContent = `–î–µ—Ä–µ–≤ –∑—Ä—É–±–∞–Ω–æ: ${treesCutTotal} | –î–µ—Ä–µ–≤–æ: ${wood}`;
}
function updateHeat(){
  const full = Math.round(heatValue);
  let s = "";
  for(let i=0;i<heatMax;i++) s += i < full ? "üî•" : "¬∑";
  heatEl.textContent = s;
}
updateStats(); updateHeat();

const player = {
  x: 0,
  y: 35,
  r: 0.60,
  dir: -Math.PI/2,      // –Ω–∞–ø—Ä—è–º (–≤ —Ä–∞–¥—ñ–∞–Ω–∞—Ö)
  attack: 0,            // 0..1
  attackCooldown: 0
};

const camera = { x: player.x, y: player.y };

/* =========================
   –ß–∞—Å—Ç–∏–Ω–∫–∏ (–µ—Ñ–µ–∫—Ç–∏)
========================= */
const particles = [];
function spawnParticles(type, x,y, count=10){
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const sp = rand(1.5, 5.5);
    particles.push({
      type,
      x, y,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp,
      life: rand(0.35, 0.75),
      t: 0
    });
  }
}

/* =========================
   –ö–µ—Ä—É–≤–∞–Ω–Ω—è: –∫–ª–∞–≤—ñ—à—ñ + –º–∏—à–∫–∞
========================= */
const keys = {};
document.addEventListener("keydown",(e)=> keys[e.code]=true);
document.addEventListener("keyup",(e)=> keys[e.code]=false);

let mouseAim = null;
window.addEventListener("mousemove",(e)=>{
  mouseAim = { x: e.clientX, y: e.clientY };
});
window.addEventListener("mouseleave",()=>{ mouseAim=null; });

function doAction(){
  if (isFrozen) return;
  if (player.attackCooldown > 0) return;

  player.attack = 0.0001;
  player.attackCooldown = 0.22;

  // 1) –∫–Ω–æ–ø–∫–∞ –≤—ñ–¥–±—É–¥–æ–≤–∏
  if (tryUseNearestButton()) return;

  // 2) —Ä—É–±–∫–∞ –¥–µ—Ä–µ–≤–∞
  chopNearestTree();
}

window.addEventListener("mousedown",(e)=>{
  if (e.button!==0) return;
  doAction();
});

/* =========================
   Touch –¥–∂–æ–π—Å—Ç–∏–∫–∏ (—Ä—É—Ö/–Ω–∞–ø—Ä—è–º)
========================= */
const movePad = document.getElementById("movePad");
const moveStick = document.getElementById("moveStick");
const lookPad = document.getElementById("lookPad");
const lookStick = document.getElementById("lookStick");
const actionBtn = document.getElementById("actionBtn");

let touchMoveX=0, touchMoveY=0;
let touchLookX=0, touchLookY=0;

function setupStick(pad, stick, onMove){
  const stickRadius = 30;
  let touchId = null;

  function reset(){
    const rect = pad.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    stick.style.left = (cx - stickRadius) + "px";
    stick.style.top  = (cy - stickRadius) + "px";
    onMove(0,0);
  }
  function updateFromTouch(t){
    const rect = pad.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    let dx = t.clientX - (rect.left + cx);
    let dy = t.clientY - (rect.top  + cy);
    const maxR = rect.width/2 - stickRadius;
    const d = Math.hypot(dx,dy);
    if (d > maxR) { dx*=maxR/d; dy*=maxR/d; }
    stick.style.left = (cx - stickRadius + dx) + "px";
    stick.style.top  = (cy - stickRadius + dy) + "px";
    onMove(dx/maxR, dy/maxR);
  }

  pad.addEventListener("touchstart",(e)=>{
    e.preventDefault();
    const t = e.changedTouches[0];
    touchId = t.identifier;
    updateFromTouch(t);
  },{ passive:false });

  pad.addEventListener("touchmove",(e)=>{
    e.preventDefault();
    if (touchId===null) return;
    for(const t of e.touches){
      if (t.identifier===touchId){ updateFromTouch(t); break; }
    }
  },{ passive:false });

  function end(e){
    if (touchId===null) return;
    for(const t of e.changedTouches){
      if (t.identifier===touchId){
        touchId=null; reset(); break;
      }
    }
  }
  pad.addEventListener("touchend", end, { passive:false });
  pad.addEventListener("touchcancel", end, { passive:false });

  reset();
}

if (movePad && moveStick){
  setupStick(movePad, moveStick, (x,y)=>{ touchMoveX=x; touchMoveY=y; });
}
if (lookPad && lookStick){
  setupStick(lookPad, lookStick, (x,y)=>{ touchLookX=x; touchLookY=y; });
}
if (actionBtn){
  const tap = (e)=>{ e.preventDefault(); doAction(); };
  actionBtn.addEventListener("click", tap);
  actionBtn.addEventListener("touchstart", tap, { passive:false });
}

/* =========================
   –í—ñ–¥–±—É–¥–æ–≤–∞/—Ä—É–±–∫–∞
========================= */
function tryUseNearestButton(){
  let best=null;
  let bestD= (2.2*2.2);

  for(const b of buttons){
    if (b.restored) continue;
    const d = dist2(player.x, player.y, b.x, b.y);
    if (d < bestD){
      bestD = d; best = b;
    }
  }
  if (!best) return false;

  if (wood < best.cost){
    best.flash = 0.22;
    return true; // "–∫–Ω–æ–ø–∫–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–∞", —â–æ–± –Ω–µ —Ä—É–±–∞—Ç–∏ –¥–µ—Ä–µ–≤–æ
  }

  wood -= best.cost;
  best.restored = true;

  // –ø–æ–∑–Ω–∞—á–∞—î–º–æ —è–∫ –≤—ñ–¥–±—É–¥–æ–≤–∞–Ω–µ + –¥–æ–¥–∞—î–º–æ –∫–æ–ª–∞–π–¥–µ—Ä–∏
  if (best.type === "house" || best.type === "bigHouse"){
    best.target.restored = true;
    best.target.restoreT = 0.0001;

    addColliderRect(
      best.target.x, best.target.y,
      best.type==="bigHouse" ? 4.1 : 3.2,
      best.type==="bigHouse" ? 4.1 : 3.2,
      "house"
    );
  } else if (best.type === "farm"){
    best.target.restored = true;
    best.target.restoreT = 0.0001;

    addColliderRect(best.target.x, best.target.y, best.target.w/2, best.target.l/2, "farm");
  } else if (best.type === "path"){
    best.target.restored = true;
    best.target.restoreT = 0.0001;
    // –¥–æ—Ä—ñ–∂–∫–∞ –∫–æ–ª–∞–π–¥–µ—Ä –Ω–µ –ø–æ—Ç—Ä—ñ–±–µ–Ω
  }

  spawnParticles("restore", best.x, best.y, 18);
  buttons = buttons.filter(x => x !== best);

  updateStats();
  return true;
}

function chopNearestTree(){
  let best=null;
  let bestD = (2.8*2.8);

  for(const t of trees){
    if (t.falling || t.removed) continue;
    const d = dist2(player.x, player.y, t.x, t.y);
    if (d < bestD){
      bestD = d; best = t;
    }
  }
  if (!best) return;

  best.hp -= 1;
  spawnParticles("chips", best.x, best.y, 12);

  if (best.hp <= 0 && !best.falling){
    best.falling = true;
    best.fallT = 0;
    // –ø—Ä–∏–±–∏—Ä–∞—î–º–æ –∫–æ–ª–∞–π–¥–µ—Ä –¥–µ—Ä–µ–≤–∞
    const idx = colliders.indexOf(best.collider);
    if (idx !== -1) colliders.splice(idx,1);

    treesCutTotal++;
    wood++;
    updateStats();
  }
}

/* =========================
   –†–µ–Ω–¥–µ—Ä —É—Ç–∏–ª—ñ—Ç–∏
========================= */
function worldToScreen(wx,wy){
  const sx = (wx - camera.x) * PPU + INTERNAL_W/2;
  const sy = (wy - camera.y) * PPU + INTERNAL_H/2;
  return { x:sx, y:sy };
}

function drawShadowCircle(ctx, x,y, r){
  ctx.fillStyle = COL.shadow;
  ctx.beginPath();
  ctx.ellipse(x, y, r*1.1, r*0.7, 0, 0, Math.PI*2);
  ctx.fill();
}

/* –ú–∞–ª—é—î–º–æ ‚Äú–ø—ñ–∫—Å–µ–ª—å–Ω—ñ‚Äù —Ñ–æ—Ä–º–∏ (–≤–∏—Ä—ñ–≤–Ω—é–≤–∞–Ω–Ω—è) */
function pRect(ctx, x,y,w,h){
  ctx.fillRect((x|0),(y|0),(w|0),(h|0));
}
function pLine(ctx,x1,y1,x2,y2){
  ctx.beginPath();
  ctx.moveTo((x1|0)+0.5,(y1|0)+0.5);
  ctx.lineTo((x2|0)+0.5,(y2|0)+0.5);
  ctx.stroke();
}

/* =========================
   –ú–∞–ª—é–≤–∞–Ω–Ω—è —Å—É—Ç–Ω–æ—Å—Ç–µ–π (2D "–º–æ–¥–µ–ª—å–∫–∏")
========================= */
function drawHouse(ctx, h){
  const t = h.restored ? 1 : 0.35;
  const fade = h.restored ? (0.35 + 0.65*easeOutCubic(h.restoreT)) : 0.38;

  const pos = worldToScreen(h.x, h.y);
  const w = h.w*PPU, l = h.h*PPU;

  drawShadowCircle(ctx, pos.x, pos.y + l*0.18, (Math.max(w,l)*0.25));

  ctx.globalAlpha = fade;

  // –±–∞–∑–∞
  ctx.fillStyle = COL.wood1;
  pRect(ctx, pos.x - w/2, pos.y - l/2, w, l);

  // –æ–±–≤–æ–¥–∫–∞
  ctx.strokeStyle = "rgba(0,0,0,0.25)";
  ctx.lineWidth = 2;
  ctx.strokeRect((pos.x - w/2)|0, (pos.y - l/2)|0, w|0, l|0);

  // –¥–∞—Ö (—Ä–æ–º–±)
  ctx.fillStyle = COL.roof1;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y - l/2 - PPU*1.8);
  ctx.lineTo(pos.x + w/2, pos.y - l/2 + PPU*0.6);
  ctx.lineTo(pos.x, pos.y - l/2 + PPU*2.2);
  ctx.lineTo(pos.x - w/2, pos.y - l/2 + PPU*0.6);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = COL.roof2;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y - l/2 - PPU*1.8);
  ctx.lineTo(pos.x, pos.y - l/2 + PPU*2.2);
  ctx.lineTo(pos.x - w/2, pos.y - l/2 + PPU*0.6);
  ctx.closePath();
  ctx.fill();

  // –¥–≤–µ—Ä—ñ/–≤—ñ–∫–Ω–æ
  ctx.fillStyle = COL.wood2;
  pRect(ctx, pos.x - PPU*0.8, pos.y + l*0.12, PPU*1.6, PPU*2.1);

  ctx.fillStyle = "rgba(235,245,255,0.75)";
  pRect(ctx, pos.x + PPU*1.2, pos.y - PPU*0.2, PPU*1.2, PPU*1.2);

  ctx.globalAlpha = 1;
}

function drawBigHouse(ctx, h){
  // –ø—Ä–æ—Å—Ç–æ —Ç—Ä–æ—Ö–∏ "–ø–æ—Ç—É–∂–Ω—ñ—à–∏–π" –¥–∞—Ö/–¥–µ—Ç–∞–ª—ñ
  drawHouse(ctx, h);
  const pos = worldToScreen(h.x, h.y);
  ctx.globalAlpha = h.restored ? (0.65 + 0.35*easeOutCubic(h.restoreT)) : 0.35;

  ctx.fillStyle = "rgba(255,255,255,0.16)";
  pRect(ctx, pos.x - (h.w*PPU)/2 + 4, pos.y - (h.h*PPU)/2 + 4, (h.w*PPU)-8, (h.h*PPU)-8);

  ctx.globalAlpha = 1;
}

function drawFarm(ctx, f){
  const fade = f.restored ? (0.35 + 0.65*easeOutCubic(f.restoreT)) : 0.38;
  const pos = worldToScreen(f.x, f.y);
  const w = f.w*PPU, l = f.l*PPU;

  drawShadowCircle(ctx, pos.x, pos.y + l*0.22, (Math.max(w,l)*0.20));

  ctx.globalAlpha = fade;

  ctx.fillStyle = COL.soil;
  pRect(ctx, pos.x - w/2, pos.y - l/2, w, l);

  // –≥—Ä—è–¥–∫–∏
  for(let row=0; row<4; row++){
    for(let col=0; col<Math.floor(f.w); col++){
      const cx = pos.x - w/2 + (col+0.5)*PPU;
      const cy = pos.y - l/2 + (row+0.6)*(l/4);
      ctx.fillStyle = COL.crop;
      pRect(ctx, cx-2, cy-3, 4, 6);
      ctx.fillStyle = "rgba(0,0,0,0.18)";
      pRect(ctx, cx-2, cy+2, 4, 1);
    }
  }

  ctx.globalAlpha = 1;
}

function drawPath(ctx, p){
  const fade = p.restored ? (0.40 + 0.60*easeOutCubic(p.restoreT)) : 0.35;
  const pos = worldToScreen(p.x, p.y);
  const w = p.w*PPU, l = p.l*PPU;

  ctx.globalAlpha = fade;
  ctx.fillStyle = COL.path;
  pRect(ctx, pos.x - w/2, pos.y - l/2, w, l);

  // ‚Äú–ø–ª–∏—Ç–∫–∏‚Äù
  ctx.fillStyle = COL.path2;
  for(let i=0;i<10;i++){
    const tx = pos.x - w/2 + Math.random()*w;
    const ty = pos.y - l/2 + Math.random()*l;
    pRect(ctx, tx, ty, 2, 2);
  }
  ctx.globalAlpha = 1;
}

function drawRock(ctx, r){
  const pos = worldToScreen(r.x, r.y);
  const s = r.size*PPU;

  drawShadowCircle(ctx, pos.x, pos.y + s*0.22, s*0.55);

  ctx.fillStyle = COL.rock;
  ctx.beginPath();
  ctx.moveTo(pos.x - s*0.6, pos.y);
  ctx.lineTo(pos.x - s*0.2, pos.y - s*0.45);
  ctx.lineTo(pos.x + s*0.55, pos.y - s*0.1);
  ctx.lineTo(pos.x + s*0.35, pos.y + s*0.50);
  ctx.lineTo(pos.x - s*0.35, pos.y + s*0.45);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = COL.rock2;
  ctx.beginPath();
  ctx.moveTo(pos.x - s*0.2, pos.y - s*0.45);
  ctx.lineTo(pos.x + s*0.15, pos.y - s*0.30);
  ctx.lineTo(pos.x + s*0.55, pos.y - s*0.1);
  ctx.lineTo(pos.x + s*0.05, pos.y - s*0.05);
  ctx.closePath();
  ctx.fill();
}

function drawMountain(ctx, m){
  const pos = worldToScreen(m.x, m.y);
  const base = m.base*PPU;
  const h = m.height*PPU;

  drawShadowCircle(ctx, pos.x, pos.y + base*0.25, base*0.80);

  ctx.fillStyle = COL.mtn;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y - h*0.55);
  ctx.lineTo(pos.x + base*0.65, pos.y + base*0.50);
  ctx.lineTo(pos.x - base*0.65, pos.y + base*0.50);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = COL.mtn2;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y - h*0.55);
  ctx.lineTo(pos.x, pos.y + base*0.50);
  ctx.lineTo(pos.x - base*0.65, pos.y + base*0.50);
  ctx.closePath();
  ctx.fill();

  // —Å–Ω—ñ–∂–Ω–∞ —à–∞–ø–∫–∞
  ctx.fillStyle = COL.snow2;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y - h*0.55);
  ctx.lineTo(pos.x + base*0.18, pos.y - h*0.30);
  ctx.lineTo(pos.x, pos.y - h*0.18);
  ctx.lineTo(pos.x - base*0.20, pos.y - h*0.30);
  ctx.closePath();
  ctx.fill();
}

function drawTree(ctx, t){
  const pos = worldToScreen(t.x, t.y);

  // –ø–∞–¥—ñ–Ω–Ω—è (–ø–æ–≤–æ—Ä–æ—Ç –Ω–∞–≤–∫–æ–ª–æ ‚Äú–ø–Ω—è‚Äù)
  const fallDur = 0.60;
  const k = t.falling ? clamp(t.fallT/fallDur, 0, 1) : 0;
  const ang = t.falling ? (k * (Math.PI/2) * t.fallDir) : 0;

  // –±–∞–∑–æ–≤–∞ —Ç—ñ–Ω—å
  drawShadowCircle(ctx, pos.x, pos.y + PPU*0.38, PPU*0.72);

  ctx.save();
  ctx.translate(pos.x, pos.y);
  ctx.rotate(ang);

  // —Å—Ç–æ–≤–±—É—Ä
  ctx.fillStyle = COL.wood2;
  pRect(ctx, -2, -PPU*0.10, 4, PPU*0.85);

  // –∫—Ä–æ–Ω–∞ (—Å–Ω—ñ–∂–Ω–∞ —è–ª–∏–Ω–∫–∞)
  ctx.fillStyle = COL.snow2;
  ctx.beginPath();
  ctx.moveTo(0, -PPU*1.55);
  ctx.lineTo(PPU*0.95, -PPU*0.10);
  ctx.lineTo(-PPU*0.95, -PPU*0.10);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = "#d9ebff";
  ctx.beginPath();
  ctx.moveTo(0, -PPU*1.35);
  ctx.lineTo(PPU*0.75, -PPU*0.25);
  ctx.lineTo(-PPU*0.75, -PPU*0.25);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function drawCampfire(ctx, time){
  const pos = worldToScreen(campfire.x, campfire.y);

  // –∫–∞–º—ñ–Ω—Ü—ñ
  for(let i=0;i<6;i++){
    const a = i*(Math.PI/3);
    const px = pos.x + Math.cos(a)*PPU*1.0;
    const py = pos.y + Math.sin(a)*PPU*0.75;
    ctx.fillStyle = COL.rock2;
    ctx.beginPath();
    ctx.arc(px, py, 4, 0, Math.PI*2);
    ctx.fill();
  }

  // –ø–æ–ª—É–º'—è + –º–µ—Ä–µ—Ö—Ç—ñ–Ω–Ω—è
  const flick = 1 + Math.sin(time*10)*0.12;
  drawShadowCircle(ctx, pos.x, pos.y + 8, 12);

  ctx.fillStyle = COL.flame;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y - 18*flick);
  ctx.quadraticCurveTo(pos.x + 10, pos.y - 4, pos.x, pos.y + 10);
  ctx.quadraticCurveTo(pos.x - 10, pos.y - 4, pos.x, pos.y - 18*flick);
  ctx.fill();

  ctx.fillStyle = COL.flame2;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y - 12*flick);
  ctx.quadraticCurveTo(pos.x + 7, pos.y - 2, pos.x, pos.y + 7);
  ctx.quadraticCurveTo(pos.x - 7, pos.y - 2, pos.x, pos.y - 12*flick);
  ctx.fill();

  // —Ç–µ–ø–ª–∏–π ‚Äú–≥–ª–æ—É‚Äù
  ctx.fillStyle = "rgba(255,120,60,0.12)";
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, 42, 0, Math.PI*2);
  ctx.fill();
}

function drawButton(ctx, b, time){
  const pos = worldToScreen(b.x, b.y);
  const pulse = 1 + Math.sin(time*5 + b.phase)*0.10;

  drawShadowCircle(ctx, pos.x, pos.y + 10, 14);

  // –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞
  ctx.fillStyle = COL.btn;
  ctx.beginPath();
  ctx.ellipse(pos.x, pos.y, 14*pulse, 10*pulse, 0, 0, Math.PI*2);
  ctx.fill();

  // –≥–ª–æ—É
  ctx.fillStyle = COL.btnGlow;
  ctx.beginPath();
  ctx.ellipse(pos.x, pos.y, 20*pulse, 14*pulse, 0, 0, Math.PI*2);
  ctx.fill();

  // ‚Äú–≤–∞—Ä—Ç—ñ—Å—Ç—å‚Äù
  ctx.font = "bold 14px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = (b.flash>0) ? "#ff4d4d" : "#ffffff";
  ctx.fillText(String(b.cost), pos.x, pos.y - 18);
}

function drawAxe(ctx, x,y, ang, swing){
  ctx.save();
  ctx.translate(x,y);
  ctx.rotate(ang + swing);

  // —Ä—É—á–∫–∞
  ctx.fillStyle = COL.wood2;
  pRect(ctx, -1, -10, 2, 18);

  // –ª–µ–∑–æ
  ctx.fillStyle = "#c3c9d3";
  pRect(ctx, 0, -7, 10, 6);
  ctx.fillStyle = "#9aa2ad";
  pRect(ctx, 0, -7, 10, 2);

  ctx.restore();
}

function drawPlayer(ctx, p, time){
  const pos = worldToScreen(p.x, p.y);
  const bob = Math.sin(time*6)*0.8;

  drawShadowCircle(ctx, pos.x, pos.y + 10, 14);

  // —Ç—ñ–ª–æ (—Å–∏–Ω—è —Å—Ñ–µ—Ä–∞)
  const r = 10;
  ctx.fillStyle = COL.blue;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y + bob, r, 0, Math.PI*2);
  ctx.fill();

  // —Ö–∞–π–ª–∞–π—Ç
  ctx.fillStyle = COL.blue2;
  ctx.beginPath();
  ctx.arc(pos.x - 3, pos.y - 3 + bob, 4, 0, Math.PI*2);
  ctx.fill();

  // —Å–æ–∫–∏—Ä–∞ –∑–±–æ–∫—É + –∞–Ω—ñ–º–∞—Ü—ñ—è —É–¥–∞—Ä—É
  const atk = p.attack>0 ? Math.sin(p.attack*Math.PI) : 0;
  const swing = -0.9*atk;
  const axeX = pos.x + Math.cos(p.dir)*14;
  const axeY = pos.y + Math.sin(p.dir)*10 + bob;
  drawAxe(ctx, axeX, axeY, p.dir + Math.PI/2, swing);
}

function drawRemotePlayer(ctx, rp, time){
  const pos = worldToScreen(rp.x, rp.y);
  drawShadowCircle(ctx, pos.x, pos.y + 10, 14);

  ctx.fillStyle = "rgba(45,108,223,0.55)";
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, 10, 0, Math.PI*2);
  ctx.fill();

  // —Å–æ–∫–∏—Ä–∞
  const axeX = pos.x + Math.cos(rp.dir)*14;
  const axeY = pos.y + Math.sin(rp.dir)*10;
  drawAxe(ctx, axeX, axeY, rp.dir + Math.PI/2, 0);

  // —ñ–º'—è
  ctx.font = "bold 12px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.fillText(rp.name, pos.x+1, pos.y - 14 + 1);
  ctx.fillStyle = "#ffffff";
  ctx.fillText(rp.name, pos.x, pos.y - 14);
}

/* =========================
   –ú—ñ–Ω—ñ–º–ø–∞
========================= */
function updateMinimap(){
  mctx.clearRect(0,0,180,180);
  mctx.fillStyle = "#132e13";
  mctx.fillRect(0,0,180,180);

  const scale = 180 / (WORLD_HALF*2);
  const toM = (wx,wy)=>({
    x: (wx + WORLD_HALF)*scale,
    y: (wy + WORLD_HALF)*scale
  });

  // –∫–æ–ª–∞–π–¥–µ—Ä–∏ (—Ç–æ—á–∫–∏)
  mctx.fillStyle = "rgba(60,255,60,0.65)";
  for(const c of colliders){
    const p = toM(c.x, c.y);
    mctx.fillRect(p.x|0, p.y|0, 2, 2);
  }

  // —ñ–Ω—à—ñ –≥—Ä–∞–≤—Ü—ñ
  mctx.fillStyle = "rgba(90,160,255,0.75)";
  remoteStates.forEach((d)=>{
    const p = toM(d.x, d.y);
    mctx.fillRect((p.x|0)-1,(p.y|0)-1,3,3);
  });

  // –≥—Ä–∞–≤–µ—Ü—å
  const mp = toM(player.x, player.y);
  mctx.save();
  mctx.translate(mp.x, mp.y);
  mctx.rotate(player.dir);
  mctx.fillStyle = "#ffffff";
  mctx.beginPath();
  mctx.moveTo(0,-6);
  mctx.lineTo(4,4);
  mctx.lineTo(-4,4);
  mctx.closePath();
  mctx.fill();
  mctx.restore();
}

/* =========================
   –°–Ω—ñ–≥ (FX canvas)
========================= */
let snowflakes = [];
function resize(){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  gameCanvas.width = Math.floor(innerWidth*dpr);
  gameCanvas.height = Math.floor(innerHeight*dpr);
  gctx.setTransform(dpr,0,0,dpr,0,0);

  fxCanvas.width = Math.floor(innerWidth*dpr);
  fxCanvas.height = Math.floor(innerHeight*dpr);
  fx.setTransform(dpr,0,0,dpr,0,0);
}
function initSnow(count=140){
  snowflakes = [];
  for(let i=0;i<count;i++){
    snowflakes.push({
      x: Math.random()*innerWidth,
      y: Math.random()*innerHeight,
      r: 1 + Math.random()*1.8,
      speed: 22 + Math.random()*36,
      drift: -10 + Math.random()*20
    });
  }
}
function updateSnow(dt){
  fx.clearRect(0,0,innerWidth,innerHeight);
  fx.fillStyle = "rgba(255,255,255,0.9)";
  for(const f of snowflakes){
    f.y += f.speed*dt;
    f.x += f.drift*dt;
    if (f.y > innerHeight + f.r){ f.y = -f.r; f.x = Math.random()*innerWidth; }
    if (f.x < -10) f.x = innerWidth + 10;
    if (f.x > innerWidth + 10) f.x = -10;

    fx.beginPath();
    fx.arc(f.x, f.y, f.r, 0, Math.PI*2);
    fx.fill();
  }
}

/* =========================
   –ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä (—è–∫ —É —Ç–µ–±–µ)
========================= */
let currentUserUid=null;
let currentUserName=null;

const gamePlayersCol = collection(db, "gamePlayers");
const remotePlayers = new Map();  // uid -> {x,y,tx,ty,dir,tdir,name}
const remoteStates = new Map();   // uid -> {name,x,y,dir}
const MAX_INACTIVE_MS = 30000;
let lastSyncTime = 0;
const SYNC_INTERVAL = 200;

function joinToPlayer(uid){
  const data = remoteStates.get(uid);
  if (!data) return;
  player.x = data.x + 2;
  player.y = data.y + 2;
  player.dir = data.dir ?? player.dir;
}

function updateMpUI(){
  if (!mpStatusEl || !mpListEl) return;

  if (!currentUserUid){
    mpStatusEl.textContent = "–ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä: —É–≤—ñ–π–¥—ñ—Ç—å —É –∞–∫–∞—É–Ω—Ç –Ω–∞ –≥–æ–ª–æ–≤–Ω–æ–º—É —Å–∞–π—Ç—ñ";
  } else {
    mpStatusEl.textContent = "–ú—É–ª—å—Ç–∏–ø–ª–µ—î—Ä: –≤–∏ " + (currentUserName || "–ì—Ä–∞–≤–µ—Ü—å");
  }

  mpListEl.innerHTML = "";
  if (remoteStates.size === 0){
    const d = document.createElement("div");
    d.textContent = "–ù–µ–º–∞—î —ñ–Ω—à–∏—Ö –≥—Ä–∞–≤—Ü—ñ–≤ —É –≥—Ä—ñ";
    mpListEl.appendChild(d);
    return;
  }

  remoteStates.forEach((data, uid)=>{
    const row = document.createElement("div");
    row.className = "playerRow";
    const name = document.createElement("div");
    name.textContent = `${data.name} —É –≥—Ä—ñ`;
    const btn = document.createElement("button");
    btn.textContent = "–ü—Ä–∏—î–¥–Ω–∞—Ç–∏—Å—è";
    btn.onclick = ()=> joinToPlayer(uid);
    row.appendChild(name);
    row.appendChild(btn);
    mpListEl.appendChild(row);
  });
}

async function syncGamePlayer(){
  if (!currentUserUid || !currentUserName) return;
  try{
    const ref = doc(gamePlayersCol, currentUserUid);
    await setDoc(ref, {
      name: currentUserName,
      x: player.x,
      y: player.y,
      dir: player.dir,
      updatedAt: serverTimestamp()
    }, { merge:true });
  }catch(err){
    console.error("–ü–æ–º–∏–ª–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó –≥—Ä–∞–≤—Ü—è:", err);
  }
}
function maybeSyncGamePlayer(){
  if (!currentUserUid || !currentUserName) return;
  const now = performance.now();
  if (now - lastSyncTime < SYNC_INTERVAL) return;
  lastSyncTime = now;
  syncGamePlayer();
}

onSnapshot(gamePlayersCol, (snapshot)=>{
  remoteStates.clear();
  const nowMs = Date.now();

  remotePlayers.forEach(p => p._seen=false);

  snapshot.forEach((docSnap)=>{
    const uid = docSnap.id;
    if (uid === currentUserUid) return;

    const data = docSnap.data() || {};
    const updatedAt = data.updatedAt?.toDate ? data.updatedAt.toDate().getTime() : 0;
    if (!updatedAt || nowMs - updatedAt > MAX_INACTIVE_MS){
      remotePlayers.delete(uid);
      return;
    }

    const name = data.name || "–ì—Ä–∞–≤–µ—Ü—å";
    const x = data.x ?? 0;
    const y = data.y ?? 2;
    const dir = data.dir ?? 0;

    remoteStates.set(uid, { name, x, y, dir });

    let rp = remotePlayers.get(uid);
    if (!rp){
      rp = { name, x, y, tx:x, ty:y, dir, tdir:dir, _seen:true };
      remotePlayers.set(uid, rp);
    } else {
      rp.name = name;
      rp.tx = x; rp.ty = y;
      rp.tdir = dir;
      rp._seen = true;
    }
  });

  // —á–∏—Å—Ç–∏–º–æ –Ω–µ–≤–∏–¥–∏–º–∏—Ö
  for(const [uid, rp] of remotePlayers){
    if (!rp._seen) remotePlayers.delete(uid);
    else delete rp._seen;
  }

  updateMpUI();
}, (err)=>{
  console.error("–ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è gamePlayers:", err);
});

onAuthStateChanged(auth, (user)=>{
  if (user && user.displayName){
    currentUserUid = user.uid;
    currentUserName = user.displayName;
  } else {
    currentUserUid = null;
    currentUserName = null;
  }
  updateMpUI();
});

/* =========================
   Game loop (—Ä—É—Ö/—Ç–µ–ø–ª–æ/–∞–Ω—ñ–º–∞—Ü—ñ—ó)
========================= */
let last = performance.now();

function update(dt, time){
  if (isFrozen){
    updateSnow(dt);
    return;
  }

  // –∫–ª–∞–≤—ñ—à—ñ —Ä—É—Ö—É
  let mx = 0, my = 0;
  if (keys["KeyW"] || keys["ArrowUp"]) my -= 1;
  if (keys["KeyS"] || keys["ArrowDown"]) my += 1;
  if (keys["KeyA"] || keys["ArrowLeft"]) mx -= 1;
  if (keys["KeyD"] || keys["ArrowRight"]) mx += 1;

  // —Ç–∞—á-—Ä—É—Ö
  if (Math.abs(touchMoveX) > 0.05 || Math.abs(touchMoveY) > 0.05){
    mx += touchMoveX;
    my += touchMoveY;
  }

  // –Ω–∞–ø—Ä—è–º (–ø—Ä–∞–≤–∏–π –¥–∂–æ–π—Å—Ç–∏–∫ / –º–∏—à–∫–∞)
  let aimUsed = false;
  if (Math.hypot(touchLookX, touchLookY) > 0.25){
    player.dir = Math.atan2(touchLookY, touchLookX);
    aimUsed = true;
  } else if (mouseAim){
    // –º–∏—à–∫–∞: –Ω–∞–ø—Ä—è–º –≤—ñ–¥ —Ü–µ–Ω—Ç—Ä—É –µ–∫—Ä–∞–Ω–∞
    const cx = innerWidth/2, cy = innerHeight/2;
    const dx = mouseAim.x - cx;
    const dy = mouseAim.y - cy;
    if (Math.hypot(dx,dy) > 10){
      player.dir = Math.atan2(dy, dx);
      aimUsed = true;
    }
  }

  // —Ä—É—Ö
  const speed = 7.8; // ‚Äú—à–≤–∏–¥–∫—ñ—Å—Ç—å —Ö–æ–¥–∏‚Äù
  const len = Math.hypot(mx,my);
  if (len > 0.001){
    mx /= len; my /= len;

    // —è–∫—â–æ –Ω–µ —Ü—ñ–ª–∏—à—Å—è ‚Äî –Ω–∞–ø—Ä—è–º –ø–æ —Ä—É—Ö—É
    if (!aimUsed) player.dir = Math.atan2(my, mx);

    const stepX = mx * speed * dt;
    const stepY = my * speed * dt;

    // –æ–∫—Ä–µ–º–æ –ø–æ –æ—Å—è—Ö (—â–æ–± –∫—Ä–∞—â–µ –∫–æ–≤–∑–∞–ª–æ)
    let nx = player.x + stepX;
    let ny = player.y;

    // –º–µ–∂—ñ —Å–≤—ñ—Ç—É
    nx = clamp(nx, -WORLD_HALF+1, WORLD_HALF-1);
    ny = clamp(ny, -WORLD_HALF+1, WORLD_HALF-1);

    if (!isBlocked(nx, ny, player.r)) player.x = nx;

    nx = player.x;
    ny = player.y + stepY;
    nx = clamp(nx, -WORLD_HALF+1, WORLD_HALF-1);
    ny = clamp(ny, -WORLD_HALF+1, WORLD_HALF-1);

    if (!isBlocked(nx, ny, player.r)) player.y = ny;
  }

  // –∞—Ç–∞–∫–∞
  if (player.attackCooldown > 0) player.attackCooldown -= dt;
  if (player.attack > 0){
    player.attack += dt * 4.0;
    if (player.attack >= 1) player.attack = 0;
  }

  // –¥–µ—Ä–µ–≤–∞ –ø–∞–¥–∞—é—Ç—å
  for(const t of trees){
    if (t.falling && !t.removed){
      t.fallT += dt;
      if (t.fallT >= 0.62){
        t.removed = true;
      }
    }
  }
  trees = trees.filter(t => !t.removed);

  // –∫–Ω–æ–ø–∫–∏ —Ñ–ª–µ—à (–∫–æ–ª–∏ –Ω–µ –≤–∏—Å—Ç–∞—á–∞—î wood)
  for(const b of buttons){
    if (b.flash > 0) b.flash -= dt;
  }

  // –≤—ñ–¥–±—É–¥–æ–≤–∞ fade-in
  for(const h of houses){
    if (h.restored && h.restoreT < 1){
      h.restoreT = Math.min(1, h.restoreT + dt*1.6);
    }
  }
  for(const f of farms){
    if (f.restored && f.restoreT < 1){
      f.restoreT = Math.min(1, f.restoreT + dt*1.6);
    }
  }
  for(const p of paths){
    if (p.restored && p.restoreT < 1){
      p.restoreT = Math.min(1, p.restoreT + dt*1.8);
    }
  }

  // —á–∞—Å—Ç–∏–Ω–∫–∏
  for(const pt of particles){
    pt.t += dt;
    pt.life -= dt;
    pt.x += pt.vx*dt;
    pt.y += pt.vy*dt;
    pt.vx *= 0.90;
    pt.vy *= 0.90;
    if (pt.type === "chips") pt.vy += 6.5*dt;
    if (pt.type === "restore") pt.vy -= 2.0*dt;
  }
  for(let i=particles.length-1;i>=0;i--){
    if (particles[i].life <= 0) particles.splice(i,1);
  }

  // —Ç–µ–ø–ª–æ/–∑–∞–º–µ—Ä–∑–∞–Ω–Ω—è
  const d = Math.sqrt(dist2(player.x, player.y, campfire.x, campfire.y));
  const warmRadius = 12;
  const coolRate = 0.025;
  const warmRate = 2.0;

  if (d < warmRadius){
    const factor = 1 - d/warmRadius;
    heatValue += warmRate * factor * dt;
  } else {
    heatValue -= coolRate * dt;
  }

  heatValue = clamp(heatValue, 0, heatMax);
  updateHeat();

  if (!isFrozen && heatValue <= 0.01){
    isFrozen = true;
    freezeOverlay.style.opacity = "1";
    freezeText.style.opacity = "1";
  }

  // –∫–∞–º–µ—Ä–∞ —Å–ª—ñ–¥—É—î
  camera.x = lerp(camera.x, player.x, 0.12);
  camera.y = lerp(camera.y, player.y, 0.12);

  // —ñ–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü—ñ—è —ñ–Ω—à–∏—Ö –≥—Ä–∞–≤—Ü—ñ–≤
  for(const rp of remotePlayers.values()){
    rp.x = lerp(rp.x, rp.tx, 0.22);
    rp.y = lerp(rp.y, rp.ty, 0.22);

    // –Ω–∞–π–∫–æ—Ä–æ—Ç—à–∏–π —à–ª—è—Ö –ø–æ –∫—É—Ç—É
    let da = (rp.tdir - rp.dir);
    while (da > Math.PI) da -= Math.PI*2;
    while (da < -Math.PI) da += Math.PI*2;
    rp.dir += da*0.22;
  }

  // —Å–Ω—ñ–≥
  updateSnow(dt);

  // –º—É–ª—å—Ç–∏–ø–ª–µ—î—Ä sync
  maybeSyncGamePlayer();
}

function render(time){
  // –∑–µ–º–ª—è
  bctx.fillStyle = groundPattern;
  bctx.fillRect(0,0,INTERNAL_W,INTERNAL_H);

  // –ª–µ–≥–∫–∞ –≤—ñ–Ω—å—î—Ç–∫–∞
  bctx.fillStyle = "rgba(0,0,0,0.05)";
  bctx.fillRect(0,0,INTERNAL_W,INTERNAL_H);

  // –º–µ–∂—ñ –≤–∏–¥–∏–º–æ—Å—Ç—ñ (culling)
  const halfW = INTERNAL_W/(2*PPU);
  const halfH = INTERNAL_H/(2*PPU);
  const minX = camera.x - halfW - 12;
  const maxX = camera.x + halfW + 12;
  const minY = camera.y - halfH - 12;
  const maxY = camera.y + halfH + 12;
  const visible = (x,y, pad=0)=> x>=minX-pad && x<=maxX+pad && y>=minY-pad && y<=maxY+pad;

  // –¥–æ—Ä—ñ–∂–∫–∏
  for(const p of paths){
    if (!visible(p.x,p.y, 12)) continue;
    drawPath(bctx, p);
  }

  // —Ñ–µ—Ä–º–∏
  for(const f of farms){
    if (!visible(f.x,f.y, 14)) continue;
    drawFarm(bctx, f);
  }

  // –±—É–¥–∏–Ω–∫–∏
  for(const h of houses){
    if (!visible(h.x,h.y, 16)) continue;
    if (h.type==="bigHouse") drawBigHouse(bctx, h);
    else drawHouse(bctx, h);
  }

  // –∫–∞–º–µ–Ω—ñ
  for(const r of rocks){
    if (!visible(r.x,r.y, 10)) continue;
    drawRock(bctx, r);
  }

  // –≥–æ—Ä–∏
  for(const m of mountains){
    if (!visible(m.x,m.y, 20)) continue;
    drawMountain(bctx, m);
  }

  // –¥–µ—Ä–µ–≤–∞
  for(const t of trees){
    if (!visible(t.x,t.y, 10)) continue;
    drawTree(bctx, t);
  }

  // –≤–æ–≥–Ω–∏—â–µ
  if (visible(campfire.x, campfire.y, 14)) drawCampfire(bctx, time);

  // –∫–Ω–æ–ø–∫–∏
  for(const b of buttons){
    if (!visible(b.x,b.y, 10)) continue;
    drawButton(bctx, b, time);
  }

  // —á–∞—Å—Ç–∏–Ω–∫–∏
  for(const pt of particles){
    const p = worldToScreen(pt.x, pt.y);
    const a = clamp(pt.life/0.75, 0, 1);
    if (pt.type === "chips"){
      bctx.fillStyle = `rgba(180,120,70,${0.85*a})`;
      bctx.fillRect((p.x|0),(p.y|0),2,2);
    } else {
      bctx.fillStyle = `rgba(110,255,170,${0.75*a})`;
      bctx.fillRect((p.x|0),(p.y|0),2,2);
    }
  }

  // —ñ–Ω—à—ñ –≥—Ä–∞–≤—Ü—ñ
  for(const rp of remotePlayers.values()){
    if (!visible(rp.x,rp.y, 12)) continue;
    drawRemotePlayer(bctx, rp, time);
  }

  // –≥—Ä–∞–≤–µ—Ü—å
  drawPlayer(bctx, player, time);

  // === –í–∏–≤—ñ–¥ –Ω–∞ –µ–∫—Ä–∞–Ω –∑ pixel upscale ===
  const screenW = innerWidth;
  const screenH = innerHeight;

  const scale = Math.max(1, Math.floor(Math.min(screenW/INTERNAL_W, screenH/INTERNAL_H)));
  const drawW = INTERNAL_W * scale;
  const drawH = INTERNAL_H * scale;
  const ox = ((screenW - drawW)/2)|0;
  const oy = ((screenH - drawH)/2)|0;

  gctx.clearRect(0,0,screenW,screenH);
  gctx.imageSmoothingEnabled = false;
  gctx.drawImage(buffer, 0,0,INTERNAL_W,INTERNAL_H, ox,oy, drawW,drawH);

  // UI
  updateMinimap();
}

function loop(now){
  const dt = Math.min(0.033, (now - last)/1000);
  last = now;
  const time = now/1000;

  update(dt, time);
  render(time);

  requestAnimationFrame(loop);
}

/* =========================
   –°—Ç–∞—Ä—Ç
========================= */
resize();
initSnow(140);
requestAnimationFrame(loop);
window.addEventListener("resize", ()=>{
  resize();
  initSnow(snowflakes.length || 140);
});

/* –ü—ñ–¥–∫–∞–∑–∫–∞: –æ–Ω–æ–≤–ª—é—î–º–æ UI –º—É–ª—å—Ç–∏–ø–ª–µ—î—Ä–∞ –æ–¥—Ä–∞–∑—É */
updateMpUI();
</script>

</body>
</html>
